//
//  SPMetaController.swift
//  SwiftySpot
//
//  Created by developer on 20.10.2023.
//

import Foundation

///Metadata processor
public class SPMetaController {
    
    fileprivate var _artists: [String: SPMetadataArtist]
    ///Artists metadata
    public var cachedArtistsMeta: [SPMetadataArtist] {
        get {
            return [SPMetadataArtist].init(_artists.values)
        }
    }
    
    fileprivate var _albums: [String: SPMetadataAlbum]
    ///Albums metadata
    public var cachedAlbumsMeta: [SPMetadataAlbum] {
        get {
            return [SPMetadataAlbum].init(_albums.values)
        }
    }
    
    fileprivate var _playlists: [String: SPPlaylist]
    ///Playlists metadata
    public var cachedPlaylists: [SPPlaylist] {
        get {
            return [SPPlaylist].init(_playlists.values)
        }
    }
    
    fileprivate var _tracks: [String: SPMetadataTrack]
    ///Tracks metadata
    public var cachedTracksMeta: [SPMetadataTrack] {
        get {
            return [SPMetadataTrack].init(_tracks.values)
        }
    }
    
    init(artists: [String : SPMetadataArtist], albums: [String : SPMetadataAlbum], tracks: [String : SPMetadataTrack], playlists: [String: SPPlaylist]) {
        self._artists = artists
        self._albums = albums
        self._playlists = playlists
        self._tracks = tracks
    }
    
    public func findArtist(uri: String) -> SPMetadataArtist? {
        if (!SPNavigateUriUtil.validateArtistUri(uri)) {
            return nil
        }
        return _artists[uri]
    }
    
    public func findArtists(uris: Set<String>) -> [SPMetadataArtist] {
        var res: [SPMetadataArtist] = []
        for uri in uris {
            guard let found = findArtist(uri: uri) else {continue}
            res.append(found)
        }
        return res
    }
    
    func updateArtists(_ dict: [String: SPMetadataArtist]) {
        for entry in dict {
            _artists[entry.key] = entry.value
        }
    }
    
    public func findAlbum(uri: String) -> SPMetadataAlbum? {
        if (!SPNavigateUriUtil.validateAlbumUri(uri)) {
            return nil
        }
        return _albums[uri]
    }
    
    public func findAlbums(uris: Set<String>) -> [SPMetadataAlbum] {
        var res: [SPMetadataAlbum] = []
        for uri in uris {
            guard let found = findAlbum(uri: uri) else {continue}
            res.append(found)
        }
        return res
    }
    
    func updateAlbums(_ dict: [String: SPMetadataAlbum]) {
        for entry in dict {
            _albums[entry.key] = entry.value
        }
    }
    
    public func findPlaylist(uri: String) -> SPPlaylist? {
        if (!SPNavigateUriUtil.validatePlaylistUri(uri)) {
            return nil
        }
        return _playlists[uri]
    }
    
    public func findPlaylists(uris: Set<String>) -> [SPPlaylist] {
        var res: [SPPlaylist] = []
        for uri in uris {
            guard let found = findPlaylist(uri: uri) else {continue}
            res.append(found)
        }
        return res
    }
    
    ///Remove outdated playlists. Use case: remove generated by spotify old playlists (daily, release and other)
    ///- Parameter playlistUris: Outdated playlist navigation uri's
    public func removeOutdatedPlaylists(_ playlistUris: [String]) {
        for uri in playlistUris {
            _ = _playlists.removeValue(forKey: uri)
        }
    }
    
    func updatePlaylists(_ dict: [String: SPPlaylist]) {
        for entry in dict {
            _playlists[entry.key] = entry.value
        }
    }
    
    public func findTrack(uri: String) -> SPMetadataTrack? {
        if (!SPNavigateUriUtil.validateTrackUri(uri)) {
            return nil
        }
        return _tracks[uri]
    }
    
    public func findTracks(uris: Set<String>) -> [String: SPMetadataTrack] {
        var res: [String: SPMetadataTrack] = [:]
        for uri in uris {
            guard let found = findTrack(uri: uri) else {continue}
            res[uri] = found
        }
        return res
    }
    
    func updateTracks(_ dict: [String: SPMetadataTrack]) {
        for entry in dict {
            _tracks[entry.key] = entry.value
        }
    }
}
