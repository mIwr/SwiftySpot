// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ExtendedMetadata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SPMetaExtensionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case generic // = 1
  case assoc // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .generic
    case 2: self = .assoc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .generic: return 1
    case .assoc: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPMetaExtensionType] = [
    .unknown,
    .generic,
    .assoc,
  ]

}

enum SPMetaExtensionKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknownExtension // = 0
  case canvaz // = 1
  case storylines // = 2
  case podcastTopics // = 3
  case podcastSegments // = 4
  case audioFiles // = 5
  case trackDescriptor // = 6
  case podcastCounter // = 7
  case artistV4 // = 8
  case albumV4 // = 9
  case trackV4 // = 10
  case showV4 // = 11
  case episodeV4 // = 12
  case podcastHtmlDescription // = 13
  case podcastQuotes // = 14
  case userProfile // = 15
  case canvasV1 // = 16
  case showV4Base // = 17
  case showV4EpisodesAssoc // = 18
  case trackDescriptorSignatures // = 19
  case podcastAdSegments // = 20
  case episodeTranscripts // = 21
  case podcastSubscriptions // = 22
  case extractedColor // = 23
  case podcastVirality // = 24
  case imageSparklesHack // = 25
  case podcastPopularityHack // = 26
  case automixMode // = 27
  case cuepoints // = 28
  case podcastPoll // = 29
  case episodeAccess // = 30
  case showAccess // = 31
  case podcastQna // = 32
  case clips // = 33
  case showV5 // = 34
  case episodeV5 // = 35
  case podcastCtaCards // = 36
  case podcastRating // = 37
  case displaySegments // = 38
  case greenroom // = 39
  case userCreated // = 40
  case showDescription // = 41
  case showHtmlDescription // = 42
  case showPlayability // = 43
  case episodeDescription // = 44
  case episodeHtmlDescription // = 45
  case episodePlayability // = 46
  case showEpisodesAssoc // = 47
  case clientConfig // = 48
  case playlistability // = 49
  case audiobookV5 // = 50
  case chapterV5 // = 51
  case audiobookSpecifics // = 52
  case episodeRanking // = 53
  case htmlDescription // = 54
  case creatorChannel // = 55
  case audiobookProviders // = 56
  case playTrait // = 57
  case contentWarning // = 58
  case imageCue // = 59
  case streamCount // = 60
  case audioAttributes // = 61
  case navigableTrait // = 62
  case nextBestEpisode // = 63
  case audiobookPrice // = 64
  case expressivePlaylists // = 65
  case dynamicShowEpisode // = 66
  case live // = 67
  case skipPlayed // = 68
  case adBreakFreePodcasts // = 69
  case associations // = 70
  case playlistEvaluation // = 71
  case cacheInvalidations // = 72
  case livestreamEntity // = 73
  case singleTapReactions // = 74
  case userComments // = 75
  case clientRestrictions // = 76
  case podcastGuest // = 77
  case playability // = 78
  case coverImage // = 79
  case shareTrait // = 80
  case instanceSharing // = 81
  case artistTour // = 82
  case audiobookGenre // = 83
  case concept // = 84
  case originalVideo // = 85
  case smartShuffle // = 86
  case liveEvents // = 87
  case audiobookRelations // = 88
  case homePocBasecard // = 89
  case audiobookSupplements // = 90
  case paidPodcastBanner // = 91
  case fewerAds // = 92
  case watchFeedShowExplorer // = 93
  case trackExtraDescriptors // = 94
  case trackExtraAudioAttributes // = 95
  case trackExtendedCredits // = 96
  case simpleTrait // = 97
  case audioAssociations // = 98
  case videoAssociations // = 99
  case playlistTuner // = 100
  case artistVideosEntrypoint // = 101
  case albumPrerelease // = 102
  case contentAlternatives // = 103
  case snapshotSharing // = 105
  case displaySegmentsCount // = 106
  case podcastFeaturedEpisode // = 107
  case podcastSponsoredContent // = 108
  case podcastEpisodeTopicsLlm // = 109
  case podcastEpisodeTopicsKg // = 110
  case episodeRankingPopularity // = 111
  case merch // = 112
  case companionContent // = 113
  case watchFeedEntityExplorer // = 114
  case anchorCardTrait // = 115
  case audioPreviewPlaybackTrait // = 116
  case videoPreviewStillTrait // = 117
  case previewCardTrait // = 118
  case shortcutsCardTrait // = 119
  case videoPreviewPlaybackTrait // = 120
  case courseSpecifics // = 121
  case concert // = 122
  case concertLocation // = 123
  case concertMarketing // = 124
  case concertPerformers // = 125
  case trackPairTransition // = 126
  case contentTypeTrait // = 127
  case nameTrait // = 128
  case artworkTrait // = 129
  case releaseDateTrait // = 130
  case creditsTrait // = 131
  case releaseUriTrait // = 132
  case entityCapping // = 133
  case lessonSpecifics // = 134
  case concertOffers // = 135
  case transitionMaps // = 136
  case artistHasConcerts // = 137
  case prerelease // = 138
  case playlistAttributesV2 // = 139
  case listAttributesV2 // = 140
  case listMetadata // = 141
  case listTunerAudioAnalysis // = 142
  case listTunerCuepoints // = 143
  case contentRatingTrait // = 144
  case copyrightTrait // = 145
  case supportedBadges // = 146
  case badges // = 147
  case previewTrait // = 148
  case rootlistabilityTrait // = 149
  case localConcerts // = 150
  case recommendedPlaylists // = 151
  case popularReleases // = 152
  case relatedReleases // = 153
  case shareRestrictions // = 154
  case concertOffer // = 155
  case concertOfferProvider // = 156
  case entityBookmarks // = 157
  case privacyTrait // = 158
  case duplicateItemsTrait // = 159
  case reorderingTrait // = 160
  case podcastResumptionSegments // = 161
  case artistExpressionVideo // = 162
  case prereleaseVideo // = 163
  case gatedEntityRelations // = 164
  case relatedCreatorsSection // = 165
  case creatorsAppearsOnSection // = 166
  case promoV1Trait // = 167
  case speechlessShareCard // = 168
  case topPlayablesSection // = 169
  case autoLens // = 170
  case promoV3Trait // = 171
  case trackContentFilter // = 172
  case highlightability // = 173
  case linkCardWithImageTrait // = 174
  case trackCloudSection // = 175
  case episodeTopics // = 176
  case videoThumbnail // = 177
  case identityTrait // = 178
  case visualIdentityTrait // = 179
  case contentTypeV2Trait // = 180
  case previewPlaybackTrait // = 181
  case consumptionExperienceTrait // = 182
  case publishingMetadataTrait // = 183
  case detailedEvaluationTrait // = 184
  case onPlatformReputationTrait // = 185
  case creditsV2Trait // = 186
  case highlightPlayabilityTrait // = 187
  case showEpisodeList // = 188
  case availableReleases // = 189
  case playlistDescriptors // = 190
  case linkCardWithAnimationsTrait // = 191
  case recap // = 192
  case audiobookCompanionContent // = 193
  case threeOhThreePlayTrait // = 194
  case artistWrapped2024Video // = 195
  case containedContentTypes // = 196
  case contentClassification // = 197
  case chapterSpecifics // = 198
  case creatorFanFunding // = 199
  case creatorPlaylistsSection // = 200
  case creatorPinnedItem // = 201
  case podcastPollV2 // = 202
  case creatorAppearsOnSection // = 203
  case artistConcerts // = 204
  case listMetadataV2 // = 205
  case artistHeadline // = 206
  case episodeAdPlacements // = 207
  case videoSocialProofPocTrait // = 208
  case artistMusicVideos // = 209
  case artistListeningParty // = 210
  case contentByOrAbout // = 211
  case playbackTrait // = 212
  case artistMusicVideosUnmapped // = 213
  case entityConnections // = 214
  case userProfileV2 // = 215
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownExtension
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownExtension
    case 1: self = .canvaz
    case 2: self = .storylines
    case 3: self = .podcastTopics
    case 4: self = .podcastSegments
    case 5: self = .audioFiles
    case 6: self = .trackDescriptor
    case 7: self = .podcastCounter
    case 8: self = .artistV4
    case 9: self = .albumV4
    case 10: self = .trackV4
    case 11: self = .showV4
    case 12: self = .episodeV4
    case 13: self = .podcastHtmlDescription
    case 14: self = .podcastQuotes
    case 15: self = .userProfile
    case 16: self = .canvasV1
    case 17: self = .showV4Base
    case 18: self = .showV4EpisodesAssoc
    case 19: self = .trackDescriptorSignatures
    case 20: self = .podcastAdSegments
    case 21: self = .episodeTranscripts
    case 22: self = .podcastSubscriptions
    case 23: self = .extractedColor
    case 24: self = .podcastVirality
    case 25: self = .imageSparklesHack
    case 26: self = .podcastPopularityHack
    case 27: self = .automixMode
    case 28: self = .cuepoints
    case 29: self = .podcastPoll
    case 30: self = .episodeAccess
    case 31: self = .showAccess
    case 32: self = .podcastQna
    case 33: self = .clips
    case 34: self = .showV5
    case 35: self = .episodeV5
    case 36: self = .podcastCtaCards
    case 37: self = .podcastRating
    case 38: self = .displaySegments
    case 39: self = .greenroom
    case 40: self = .userCreated
    case 41: self = .showDescription
    case 42: self = .showHtmlDescription
    case 43: self = .showPlayability
    case 44: self = .episodeDescription
    case 45: self = .episodeHtmlDescription
    case 46: self = .episodePlayability
    case 47: self = .showEpisodesAssoc
    case 48: self = .clientConfig
    case 49: self = .playlistability
    case 50: self = .audiobookV5
    case 51: self = .chapterV5
    case 52: self = .audiobookSpecifics
    case 53: self = .episodeRanking
    case 54: self = .htmlDescription
    case 55: self = .creatorChannel
    case 56: self = .audiobookProviders
    case 57: self = .playTrait
    case 58: self = .contentWarning
    case 59: self = .imageCue
    case 60: self = .streamCount
    case 61: self = .audioAttributes
    case 62: self = .navigableTrait
    case 63: self = .nextBestEpisode
    case 64: self = .audiobookPrice
    case 65: self = .expressivePlaylists
    case 66: self = .dynamicShowEpisode
    case 67: self = .live
    case 68: self = .skipPlayed
    case 69: self = .adBreakFreePodcasts
    case 70: self = .associations
    case 71: self = .playlistEvaluation
    case 72: self = .cacheInvalidations
    case 73: self = .livestreamEntity
    case 74: self = .singleTapReactions
    case 75: self = .userComments
    case 76: self = .clientRestrictions
    case 77: self = .podcastGuest
    case 78: self = .playability
    case 79: self = .coverImage
    case 80: self = .shareTrait
    case 81: self = .instanceSharing
    case 82: self = .artistTour
    case 83: self = .audiobookGenre
    case 84: self = .concept
    case 85: self = .originalVideo
    case 86: self = .smartShuffle
    case 87: self = .liveEvents
    case 88: self = .audiobookRelations
    case 89: self = .homePocBasecard
    case 90: self = .audiobookSupplements
    case 91: self = .paidPodcastBanner
    case 92: self = .fewerAds
    case 93: self = .watchFeedShowExplorer
    case 94: self = .trackExtraDescriptors
    case 95: self = .trackExtraAudioAttributes
    case 96: self = .trackExtendedCredits
    case 97: self = .simpleTrait
    case 98: self = .audioAssociations
    case 99: self = .videoAssociations
    case 100: self = .playlistTuner
    case 101: self = .artistVideosEntrypoint
    case 102: self = .albumPrerelease
    case 103: self = .contentAlternatives
    case 105: self = .snapshotSharing
    case 106: self = .displaySegmentsCount
    case 107: self = .podcastFeaturedEpisode
    case 108: self = .podcastSponsoredContent
    case 109: self = .podcastEpisodeTopicsLlm
    case 110: self = .podcastEpisodeTopicsKg
    case 111: self = .episodeRankingPopularity
    case 112: self = .merch
    case 113: self = .companionContent
    case 114: self = .watchFeedEntityExplorer
    case 115: self = .anchorCardTrait
    case 116: self = .audioPreviewPlaybackTrait
    case 117: self = .videoPreviewStillTrait
    case 118: self = .previewCardTrait
    case 119: self = .shortcutsCardTrait
    case 120: self = .videoPreviewPlaybackTrait
    case 121: self = .courseSpecifics
    case 122: self = .concert
    case 123: self = .concertLocation
    case 124: self = .concertMarketing
    case 125: self = .concertPerformers
    case 126: self = .trackPairTransition
    case 127: self = .contentTypeTrait
    case 128: self = .nameTrait
    case 129: self = .artworkTrait
    case 130: self = .releaseDateTrait
    case 131: self = .creditsTrait
    case 132: self = .releaseUriTrait
    case 133: self = .entityCapping
    case 134: self = .lessonSpecifics
    case 135: self = .concertOffers
    case 136: self = .transitionMaps
    case 137: self = .artistHasConcerts
    case 138: self = .prerelease
    case 139: self = .playlistAttributesV2
    case 140: self = .listAttributesV2
    case 141: self = .listMetadata
    case 142: self = .listTunerAudioAnalysis
    case 143: self = .listTunerCuepoints
    case 144: self = .contentRatingTrait
    case 145: self = .copyrightTrait
    case 146: self = .supportedBadges
    case 147: self = .badges
    case 148: self = .previewTrait
    case 149: self = .rootlistabilityTrait
    case 150: self = .localConcerts
    case 151: self = .recommendedPlaylists
    case 152: self = .popularReleases
    case 153: self = .relatedReleases
    case 154: self = .shareRestrictions
    case 155: self = .concertOffer
    case 156: self = .concertOfferProvider
    case 157: self = .entityBookmarks
    case 158: self = .privacyTrait
    case 159: self = .duplicateItemsTrait
    case 160: self = .reorderingTrait
    case 161: self = .podcastResumptionSegments
    case 162: self = .artistExpressionVideo
    case 163: self = .prereleaseVideo
    case 164: self = .gatedEntityRelations
    case 165: self = .relatedCreatorsSection
    case 166: self = .creatorsAppearsOnSection
    case 167: self = .promoV1Trait
    case 168: self = .speechlessShareCard
    case 169: self = .topPlayablesSection
    case 170: self = .autoLens
    case 171: self = .promoV3Trait
    case 172: self = .trackContentFilter
    case 173: self = .highlightability
    case 174: self = .linkCardWithImageTrait
    case 175: self = .trackCloudSection
    case 176: self = .episodeTopics
    case 177: self = .videoThumbnail
    case 178: self = .identityTrait
    case 179: self = .visualIdentityTrait
    case 180: self = .contentTypeV2Trait
    case 181: self = .previewPlaybackTrait
    case 182: self = .consumptionExperienceTrait
    case 183: self = .publishingMetadataTrait
    case 184: self = .detailedEvaluationTrait
    case 185: self = .onPlatformReputationTrait
    case 186: self = .creditsV2Trait
    case 187: self = .highlightPlayabilityTrait
    case 188: self = .showEpisodeList
    case 189: self = .availableReleases
    case 190: self = .playlistDescriptors
    case 191: self = .linkCardWithAnimationsTrait
    case 192: self = .recap
    case 193: self = .audiobookCompanionContent
    case 194: self = .threeOhThreePlayTrait
    case 195: self = .artistWrapped2024Video
    case 196: self = .containedContentTypes
    case 197: self = .contentClassification
    case 198: self = .chapterSpecifics
    case 199: self = .creatorFanFunding
    case 200: self = .creatorPlaylistsSection
    case 201: self = .creatorPinnedItem
    case 202: self = .podcastPollV2
    case 203: self = .creatorAppearsOnSection
    case 204: self = .artistConcerts
    case 205: self = .listMetadataV2
    case 206: self = .artistHeadline
    case 207: self = .episodeAdPlacements
    case 208: self = .videoSocialProofPocTrait
    case 209: self = .artistMusicVideos
    case 210: self = .artistListeningParty
    case 211: self = .contentByOrAbout
    case 212: self = .playbackTrait
    case 213: self = .artistMusicVideosUnmapped
    case 214: self = .entityConnections
    case 215: self = .userProfileV2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownExtension: return 0
    case .canvaz: return 1
    case .storylines: return 2
    case .podcastTopics: return 3
    case .podcastSegments: return 4
    case .audioFiles: return 5
    case .trackDescriptor: return 6
    case .podcastCounter: return 7
    case .artistV4: return 8
    case .albumV4: return 9
    case .trackV4: return 10
    case .showV4: return 11
    case .episodeV4: return 12
    case .podcastHtmlDescription: return 13
    case .podcastQuotes: return 14
    case .userProfile: return 15
    case .canvasV1: return 16
    case .showV4Base: return 17
    case .showV4EpisodesAssoc: return 18
    case .trackDescriptorSignatures: return 19
    case .podcastAdSegments: return 20
    case .episodeTranscripts: return 21
    case .podcastSubscriptions: return 22
    case .extractedColor: return 23
    case .podcastVirality: return 24
    case .imageSparklesHack: return 25
    case .podcastPopularityHack: return 26
    case .automixMode: return 27
    case .cuepoints: return 28
    case .podcastPoll: return 29
    case .episodeAccess: return 30
    case .showAccess: return 31
    case .podcastQna: return 32
    case .clips: return 33
    case .showV5: return 34
    case .episodeV5: return 35
    case .podcastCtaCards: return 36
    case .podcastRating: return 37
    case .displaySegments: return 38
    case .greenroom: return 39
    case .userCreated: return 40
    case .showDescription: return 41
    case .showHtmlDescription: return 42
    case .showPlayability: return 43
    case .episodeDescription: return 44
    case .episodeHtmlDescription: return 45
    case .episodePlayability: return 46
    case .showEpisodesAssoc: return 47
    case .clientConfig: return 48
    case .playlistability: return 49
    case .audiobookV5: return 50
    case .chapterV5: return 51
    case .audiobookSpecifics: return 52
    case .episodeRanking: return 53
    case .htmlDescription: return 54
    case .creatorChannel: return 55
    case .audiobookProviders: return 56
    case .playTrait: return 57
    case .contentWarning: return 58
    case .imageCue: return 59
    case .streamCount: return 60
    case .audioAttributes: return 61
    case .navigableTrait: return 62
    case .nextBestEpisode: return 63
    case .audiobookPrice: return 64
    case .expressivePlaylists: return 65
    case .dynamicShowEpisode: return 66
    case .live: return 67
    case .skipPlayed: return 68
    case .adBreakFreePodcasts: return 69
    case .associations: return 70
    case .playlistEvaluation: return 71
    case .cacheInvalidations: return 72
    case .livestreamEntity: return 73
    case .singleTapReactions: return 74
    case .userComments: return 75
    case .clientRestrictions: return 76
    case .podcastGuest: return 77
    case .playability: return 78
    case .coverImage: return 79
    case .shareTrait: return 80
    case .instanceSharing: return 81
    case .artistTour: return 82
    case .audiobookGenre: return 83
    case .concept: return 84
    case .originalVideo: return 85
    case .smartShuffle: return 86
    case .liveEvents: return 87
    case .audiobookRelations: return 88
    case .homePocBasecard: return 89
    case .audiobookSupplements: return 90
    case .paidPodcastBanner: return 91
    case .fewerAds: return 92
    case .watchFeedShowExplorer: return 93
    case .trackExtraDescriptors: return 94
    case .trackExtraAudioAttributes: return 95
    case .trackExtendedCredits: return 96
    case .simpleTrait: return 97
    case .audioAssociations: return 98
    case .videoAssociations: return 99
    case .playlistTuner: return 100
    case .artistVideosEntrypoint: return 101
    case .albumPrerelease: return 102
    case .contentAlternatives: return 103
    case .snapshotSharing: return 105
    case .displaySegmentsCount: return 106
    case .podcastFeaturedEpisode: return 107
    case .podcastSponsoredContent: return 108
    case .podcastEpisodeTopicsLlm: return 109
    case .podcastEpisodeTopicsKg: return 110
    case .episodeRankingPopularity: return 111
    case .merch: return 112
    case .companionContent: return 113
    case .watchFeedEntityExplorer: return 114
    case .anchorCardTrait: return 115
    case .audioPreviewPlaybackTrait: return 116
    case .videoPreviewStillTrait: return 117
    case .previewCardTrait: return 118
    case .shortcutsCardTrait: return 119
    case .videoPreviewPlaybackTrait: return 120
    case .courseSpecifics: return 121
    case .concert: return 122
    case .concertLocation: return 123
    case .concertMarketing: return 124
    case .concertPerformers: return 125
    case .trackPairTransition: return 126
    case .contentTypeTrait: return 127
    case .nameTrait: return 128
    case .artworkTrait: return 129
    case .releaseDateTrait: return 130
    case .creditsTrait: return 131
    case .releaseUriTrait: return 132
    case .entityCapping: return 133
    case .lessonSpecifics: return 134
    case .concertOffers: return 135
    case .transitionMaps: return 136
    case .artistHasConcerts: return 137
    case .prerelease: return 138
    case .playlistAttributesV2: return 139
    case .listAttributesV2: return 140
    case .listMetadata: return 141
    case .listTunerAudioAnalysis: return 142
    case .listTunerCuepoints: return 143
    case .contentRatingTrait: return 144
    case .copyrightTrait: return 145
    case .supportedBadges: return 146
    case .badges: return 147
    case .previewTrait: return 148
    case .rootlistabilityTrait: return 149
    case .localConcerts: return 150
    case .recommendedPlaylists: return 151
    case .popularReleases: return 152
    case .relatedReleases: return 153
    case .shareRestrictions: return 154
    case .concertOffer: return 155
    case .concertOfferProvider: return 156
    case .entityBookmarks: return 157
    case .privacyTrait: return 158
    case .duplicateItemsTrait: return 159
    case .reorderingTrait: return 160
    case .podcastResumptionSegments: return 161
    case .artistExpressionVideo: return 162
    case .prereleaseVideo: return 163
    case .gatedEntityRelations: return 164
    case .relatedCreatorsSection: return 165
    case .creatorsAppearsOnSection: return 166
    case .promoV1Trait: return 167
    case .speechlessShareCard: return 168
    case .topPlayablesSection: return 169
    case .autoLens: return 170
    case .promoV3Trait: return 171
    case .trackContentFilter: return 172
    case .highlightability: return 173
    case .linkCardWithImageTrait: return 174
    case .trackCloudSection: return 175
    case .episodeTopics: return 176
    case .videoThumbnail: return 177
    case .identityTrait: return 178
    case .visualIdentityTrait: return 179
    case .contentTypeV2Trait: return 180
    case .previewPlaybackTrait: return 181
    case .consumptionExperienceTrait: return 182
    case .publishingMetadataTrait: return 183
    case .detailedEvaluationTrait: return 184
    case .onPlatformReputationTrait: return 185
    case .creditsV2Trait: return 186
    case .highlightPlayabilityTrait: return 187
    case .showEpisodeList: return 188
    case .availableReleases: return 189
    case .playlistDescriptors: return 190
    case .linkCardWithAnimationsTrait: return 191
    case .recap: return 192
    case .audiobookCompanionContent: return 193
    case .threeOhThreePlayTrait: return 194
    case .artistWrapped2024Video: return 195
    case .containedContentTypes: return 196
    case .contentClassification: return 197
    case .chapterSpecifics: return 198
    case .creatorFanFunding: return 199
    case .creatorPlaylistsSection: return 200
    case .creatorPinnedItem: return 201
    case .podcastPollV2: return 202
    case .creatorAppearsOnSection: return 203
    case .artistConcerts: return 204
    case .listMetadataV2: return 205
    case .artistHeadline: return 206
    case .episodeAdPlacements: return 207
    case .videoSocialProofPocTrait: return 208
    case .artistMusicVideos: return 209
    case .artistListeningParty: return 210
    case .contentByOrAbout: return 211
    case .playbackTrait: return 212
    case .artistMusicVideosUnmapped: return 213
    case .entityConnections: return 214
    case .userProfileV2: return 215
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPMetaExtensionKind] = [
    .unknownExtension,
    .canvaz,
    .storylines,
    .podcastTopics,
    .podcastSegments,
    .audioFiles,
    .trackDescriptor,
    .podcastCounter,
    .artistV4,
    .albumV4,
    .trackV4,
    .showV4,
    .episodeV4,
    .podcastHtmlDescription,
    .podcastQuotes,
    .userProfile,
    .canvasV1,
    .showV4Base,
    .showV4EpisodesAssoc,
    .trackDescriptorSignatures,
    .podcastAdSegments,
    .episodeTranscripts,
    .podcastSubscriptions,
    .extractedColor,
    .podcastVirality,
    .imageSparklesHack,
    .podcastPopularityHack,
    .automixMode,
    .cuepoints,
    .podcastPoll,
    .episodeAccess,
    .showAccess,
    .podcastQna,
    .clips,
    .showV5,
    .episodeV5,
    .podcastCtaCards,
    .podcastRating,
    .displaySegments,
    .greenroom,
    .userCreated,
    .showDescription,
    .showHtmlDescription,
    .showPlayability,
    .episodeDescription,
    .episodeHtmlDescription,
    .episodePlayability,
    .showEpisodesAssoc,
    .clientConfig,
    .playlistability,
    .audiobookV5,
    .chapterV5,
    .audiobookSpecifics,
    .episodeRanking,
    .htmlDescription,
    .creatorChannel,
    .audiobookProviders,
    .playTrait,
    .contentWarning,
    .imageCue,
    .streamCount,
    .audioAttributes,
    .navigableTrait,
    .nextBestEpisode,
    .audiobookPrice,
    .expressivePlaylists,
    .dynamicShowEpisode,
    .live,
    .skipPlayed,
    .adBreakFreePodcasts,
    .associations,
    .playlistEvaluation,
    .cacheInvalidations,
    .livestreamEntity,
    .singleTapReactions,
    .userComments,
    .clientRestrictions,
    .podcastGuest,
    .playability,
    .coverImage,
    .shareTrait,
    .instanceSharing,
    .artistTour,
    .audiobookGenre,
    .concept,
    .originalVideo,
    .smartShuffle,
    .liveEvents,
    .audiobookRelations,
    .homePocBasecard,
    .audiobookSupplements,
    .paidPodcastBanner,
    .fewerAds,
    .watchFeedShowExplorer,
    .trackExtraDescriptors,
    .trackExtraAudioAttributes,
    .trackExtendedCredits,
    .simpleTrait,
    .audioAssociations,
    .videoAssociations,
    .playlistTuner,
    .artistVideosEntrypoint,
    .albumPrerelease,
    .contentAlternatives,
    .snapshotSharing,
    .displaySegmentsCount,
    .podcastFeaturedEpisode,
    .podcastSponsoredContent,
    .podcastEpisodeTopicsLlm,
    .podcastEpisodeTopicsKg,
    .episodeRankingPopularity,
    .merch,
    .companionContent,
    .watchFeedEntityExplorer,
    .anchorCardTrait,
    .audioPreviewPlaybackTrait,
    .videoPreviewStillTrait,
    .previewCardTrait,
    .shortcutsCardTrait,
    .videoPreviewPlaybackTrait,
    .courseSpecifics,
    .concert,
    .concertLocation,
    .concertMarketing,
    .concertPerformers,
    .trackPairTransition,
    .contentTypeTrait,
    .nameTrait,
    .artworkTrait,
    .releaseDateTrait,
    .creditsTrait,
    .releaseUriTrait,
    .entityCapping,
    .lessonSpecifics,
    .concertOffers,
    .transitionMaps,
    .artistHasConcerts,
    .prerelease,
    .playlistAttributesV2,
    .listAttributesV2,
    .listMetadata,
    .listTunerAudioAnalysis,
    .listTunerCuepoints,
    .contentRatingTrait,
    .copyrightTrait,
    .supportedBadges,
    .badges,
    .previewTrait,
    .rootlistabilityTrait,
    .localConcerts,
    .recommendedPlaylists,
    .popularReleases,
    .relatedReleases,
    .shareRestrictions,
    .concertOffer,
    .concertOfferProvider,
    .entityBookmarks,
    .privacyTrait,
    .duplicateItemsTrait,
    .reorderingTrait,
    .podcastResumptionSegments,
    .artistExpressionVideo,
    .prereleaseVideo,
    .gatedEntityRelations,
    .relatedCreatorsSection,
    .creatorsAppearsOnSection,
    .promoV1Trait,
    .speechlessShareCard,
    .topPlayablesSection,
    .autoLens,
    .promoV3Trait,
    .trackContentFilter,
    .highlightability,
    .linkCardWithImageTrait,
    .trackCloudSection,
    .episodeTopics,
    .videoThumbnail,
    .identityTrait,
    .visualIdentityTrait,
    .contentTypeV2Trait,
    .previewPlaybackTrait,
    .consumptionExperienceTrait,
    .publishingMetadataTrait,
    .detailedEvaluationTrait,
    .onPlatformReputationTrait,
    .creditsV2Trait,
    .highlightPlayabilityTrait,
    .showEpisodeList,
    .availableReleases,
    .playlistDescriptors,
    .linkCardWithAnimationsTrait,
    .recap,
    .audiobookCompanionContent,
    .threeOhThreePlayTrait,
    .artistWrapped2024Video,
    .containedContentTypes,
    .contentClassification,
    .chapterSpecifics,
    .creatorFanFunding,
    .creatorPlaylistsSection,
    .creatorPinnedItem,
    .podcastPollV2,
    .creatorAppearsOnSection,
    .artistConcerts,
    .listMetadataV2,
    .artistHeadline,
    .episodeAdPlacements,
    .videoSocialProofPocTrait,
    .artistMusicVideos,
    .artistListeningParty,
    .contentByOrAbout,
    .playbackTrait,
    .artistMusicVideosUnmapped,
    .entityConnections,
    .userProfileV2,
  ]

}

struct SPMetaBatchedEntityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: SPMetaBatchedEntityRequestHeader {
    get {return _header ?? SPMetaBatchedEntityRequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var request: [SPMetaEntityRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: SPMetaBatchedEntityRequestHeader? = nil
}

struct SPMetaBatchedEntityRequestHeader: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var country: String = String()

  var catalogue: String = String()

  var taskID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaEntityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var query: [SPMetaExtensionQuery] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaExtensionQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: SPMetaExtensionKind = .unknownExtension

  var etag: String {
    get {return _etag ?? String()}
    set {_etag = newValue}
  }
  /// Returns true if `etag` has been explicitly set.
  var hasEtag: Bool {return self._etag != nil}
  /// Clears the value of `etag`. Subsequent reads from it will return its default value.
  mutating func clearEtag() {self._etag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _etag: String? = nil
}

struct SPMetaBatchedExtensionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: SPMetaBatchedExtensionResponseHeader {
    get {return _header ?? SPMetaBatchedExtensionResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var extendedMetadata: [SPMetaEntityExtensionDataArray] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: SPMetaBatchedExtensionResponseHeader? = nil
}

struct SPMetaBatchedExtensionResponseHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaEntityExtensionDataArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: SPMetaEntityExtensionDataArrayHeader {
    get {return _header ?? SPMetaEntityExtensionDataArrayHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var kind: SPMetaExtensionKind = .unknownExtension

  var extensionData: [SPMetaEntityExtensionData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: SPMetaEntityExtensionDataArrayHeader? = nil
}

struct SPMetaEntityExtensionDataArrayHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providerErrorStatus: Int32 = 0

  var cacheTtlInSeconds: Int64 = 0

  var offlineTtlInSeconds: Int64 = 0

  var extensionType: SPMetaExtensionType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaEntityExtensionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: SPMetaEntityExtensionDataHeader {
    get {return _header ?? SPMetaEntityExtensionDataHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var entityUri: String = String()

  ///Metadata object
  var extensionData: SwiftProtobuf.Google_Protobuf_Any {
    get {return _extensionData ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_extensionData = newValue}
  }
  /// Returns true if `extensionData` has been explicitly set.
  var hasExtensionData: Bool {return self._extensionData != nil}
  /// Clears the value of `extensionData`. Subsequent reads from it will return its default value.
  mutating func clearExtensionData() {self._extensionData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: SPMetaEntityExtensionDataHeader? = nil
  fileprivate var _extensionData: SwiftProtobuf.Google_Protobuf_Any? = nil
}

struct SPMetaEntityExtensionDataHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusCode: Int32 = 0

  var etag: String = String()

  var locale: String = String()

  var cacheTtlInSeconds: Int64 = 0

  var offlineTtlInSeconds: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaPlainListAssoc: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entityUri: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaAssocHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPMetaAssoc: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: SPMetaAssocHeader {
    get {return _header ?? SPMetaAssocHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var plainList: SPMetaPlainListAssoc {
    get {return _plainList ?? SPMetaPlainListAssoc()}
    set {_plainList = newValue}
  }
  /// Returns true if `plainList` has been explicitly set.
  var hasPlainList: Bool {return self._plainList != nil}
  /// Clears the value of `plainList`. Subsequent reads from it will return its default value.
  mutating func clearPlainList() {self._plainList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: SPMetaAssocHeader? = nil
  fileprivate var _plainList: SPMetaPlainListAssoc? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.spotify.extendedmetadata.proto"

extension SPMetaExtensionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GENERIC"),
    2: .same(proto: "ASSOC"),
  ]
}

extension SPMetaExtensionKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EXTENSION"),
    1: .same(proto: "CANVAZ"),
    2: .same(proto: "STORYLINES"),
    3: .same(proto: "PODCAST_TOPICS"),
    4: .same(proto: "PODCAST_SEGMENTS"),
    5: .same(proto: "AUDIO_FILES"),
    6: .same(proto: "TRACK_DESCRIPTOR"),
    7: .same(proto: "PODCAST_COUNTER"),
    8: .same(proto: "ARTIST_V4"),
    9: .same(proto: "ALBUM_V4"),
    10: .same(proto: "TRACK_V4"),
    11: .same(proto: "SHOW_V4"),
    12: .same(proto: "EPISODE_V4"),
    13: .same(proto: "PODCAST_HTML_DESCRIPTION"),
    14: .same(proto: "PODCAST_QUOTES"),
    15: .same(proto: "USER_PROFILE"),
    16: .same(proto: "CANVAS_V1"),
    17: .same(proto: "SHOW_V4_BASE"),
    18: .same(proto: "SHOW_V4_EPISODES_ASSOC"),
    19: .same(proto: "TRACK_DESCRIPTOR_SIGNATURES"),
    20: .same(proto: "PODCAST_AD_SEGMENTS"),
    21: .same(proto: "EPISODE_TRANSCRIPTS"),
    22: .same(proto: "PODCAST_SUBSCRIPTIONS"),
    23: .same(proto: "EXTRACTED_COLOR"),
    24: .same(proto: "PODCAST_VIRALITY"),
    25: .same(proto: "IMAGE_SPARKLES_HACK"),
    26: .same(proto: "PODCAST_POPULARITY_HACK"),
    27: .same(proto: "AUTOMIX_MODE"),
    28: .same(proto: "CUEPOINTS"),
    29: .same(proto: "PODCAST_POLL"),
    30: .same(proto: "EPISODE_ACCESS"),
    31: .same(proto: "SHOW_ACCESS"),
    32: .same(proto: "PODCAST_QNA"),
    33: .same(proto: "CLIPS"),
    34: .same(proto: "SHOW_V5"),
    35: .same(proto: "EPISODE_V5"),
    36: .same(proto: "PODCAST_CTA_CARDS"),
    37: .same(proto: "PODCAST_RATING"),
    38: .same(proto: "DISPLAY_SEGMENTS"),
    39: .same(proto: "GREENROOM"),
    40: .same(proto: "USER_CREATED"),
    41: .same(proto: "SHOW_DESCRIPTION"),
    42: .same(proto: "SHOW_HTML_DESCRIPTION"),
    43: .same(proto: "SHOW_PLAYABILITY"),
    44: .same(proto: "EPISODE_DESCRIPTION"),
    45: .same(proto: "EPISODE_HTML_DESCRIPTION"),
    46: .same(proto: "EPISODE_PLAYABILITY"),
    47: .same(proto: "SHOW_EPISODES_ASSOC"),
    48: .same(proto: "CLIENT_CONFIG"),
    49: .same(proto: "PLAYLISTABILITY"),
    50: .same(proto: "AUDIOBOOK_V5"),
    51: .same(proto: "CHAPTER_V5"),
    52: .same(proto: "AUDIOBOOK_SPECIFICS"),
    53: .same(proto: "EPISODE_RANKING"),
    54: .same(proto: "HTML_DESCRIPTION"),
    55: .same(proto: "CREATOR_CHANNEL"),
    56: .same(proto: "AUDIOBOOK_PROVIDERS"),
    57: .same(proto: "PLAY_TRAIT"),
    58: .same(proto: "CONTENT_WARNING"),
    59: .same(proto: "IMAGE_CUE"),
    60: .same(proto: "STREAM_COUNT"),
    61: .same(proto: "AUDIO_ATTRIBUTES"),
    62: .same(proto: "NAVIGABLE_TRAIT"),
    63: .same(proto: "NEXT_BEST_EPISODE"),
    64: .same(proto: "AUDIOBOOK_PRICE"),
    65: .same(proto: "EXPRESSIVE_PLAYLISTS"),
    66: .same(proto: "DYNAMIC_SHOW_EPISODE"),
    67: .same(proto: "LIVE"),
    68: .same(proto: "SKIP_PLAYED"),
    69: .same(proto: "AD_BREAK_FREE_PODCASTS"),
    70: .same(proto: "ASSOCIATIONS"),
    71: .same(proto: "PLAYLIST_EVALUATION"),
    72: .same(proto: "CACHE_INVALIDATIONS"),
    73: .same(proto: "LIVESTREAM_ENTITY"),
    74: .same(proto: "SINGLE_TAP_REACTIONS"),
    75: .same(proto: "USER_COMMENTS"),
    76: .same(proto: "CLIENT_RESTRICTIONS"),
    77: .same(proto: "PODCAST_GUEST"),
    78: .same(proto: "PLAYABILITY"),
    79: .same(proto: "COVER_IMAGE"),
    80: .same(proto: "SHARE_TRAIT"),
    81: .same(proto: "INSTANCE_SHARING"),
    82: .same(proto: "ARTIST_TOUR"),
    83: .same(proto: "AUDIOBOOK_GENRE"),
    84: .same(proto: "CONCEPT"),
    85: .same(proto: "ORIGINAL_VIDEO"),
    86: .same(proto: "SMART_SHUFFLE"),
    87: .same(proto: "LIVE_EVENTS"),
    88: .same(proto: "AUDIOBOOK_RELATIONS"),
    89: .same(proto: "HOME_POC_BASECARD"),
    90: .same(proto: "AUDIOBOOK_SUPPLEMENTS"),
    91: .same(proto: "PAID_PODCAST_BANNER"),
    92: .same(proto: "FEWER_ADS"),
    93: .same(proto: "WATCH_FEED_SHOW_EXPLORER"),
    94: .same(proto: "TRACK_EXTRA_DESCRIPTORS"),
    95: .same(proto: "TRACK_EXTRA_AUDIO_ATTRIBUTES"),
    96: .same(proto: "TRACK_EXTENDED_CREDITS"),
    97: .same(proto: "SIMPLE_TRAIT"),
    98: .same(proto: "AUDIO_ASSOCIATIONS"),
    99: .same(proto: "VIDEO_ASSOCIATIONS"),
    100: .same(proto: "PLAYLIST_TUNER"),
    101: .same(proto: "ARTIST_VIDEOS_ENTRYPOINT"),
    102: .same(proto: "ALBUM_PRERELEASE"),
    103: .same(proto: "CONTENT_ALTERNATIVES"),
    105: .same(proto: "SNAPSHOT_SHARING"),
    106: .same(proto: "DISPLAY_SEGMENTS_COUNT"),
    107: .same(proto: "PODCAST_FEATURED_EPISODE"),
    108: .same(proto: "PODCAST_SPONSORED_CONTENT"),
    109: .same(proto: "PODCAST_EPISODE_TOPICS_LLM"),
    110: .same(proto: "PODCAST_EPISODE_TOPICS_KG"),
    111: .same(proto: "EPISODE_RANKING_POPULARITY"),
    112: .same(proto: "MERCH"),
    113: .same(proto: "COMPANION_CONTENT"),
    114: .same(proto: "WATCH_FEED_ENTITY_EXPLORER"),
    115: .same(proto: "ANCHOR_CARD_TRAIT"),
    116: .same(proto: "AUDIO_PREVIEW_PLAYBACK_TRAIT"),
    117: .same(proto: "VIDEO_PREVIEW_STILL_TRAIT"),
    118: .same(proto: "PREVIEW_CARD_TRAIT"),
    119: .same(proto: "SHORTCUTS_CARD_TRAIT"),
    120: .same(proto: "VIDEO_PREVIEW_PLAYBACK_TRAIT"),
    121: .same(proto: "COURSE_SPECIFICS"),
    122: .same(proto: "CONCERT"),
    123: .same(proto: "CONCERT_LOCATION"),
    124: .same(proto: "CONCERT_MARKETING"),
    125: .same(proto: "CONCERT_PERFORMERS"),
    126: .same(proto: "TRACK_PAIR_TRANSITION"),
    127: .same(proto: "CONTENT_TYPE_TRAIT"),
    128: .same(proto: "NAME_TRAIT"),
    129: .same(proto: "ARTWORK_TRAIT"),
    130: .same(proto: "RELEASE_DATE_TRAIT"),
    131: .same(proto: "CREDITS_TRAIT"),
    132: .same(proto: "RELEASE_URI_TRAIT"),
    133: .same(proto: "ENTITY_CAPPING"),
    134: .same(proto: "LESSON_SPECIFICS"),
    135: .same(proto: "CONCERT_OFFERS"),
    136: .same(proto: "TRANSITION_MAPS"),
    137: .same(proto: "ARTIST_HAS_CONCERTS"),
    138: .same(proto: "PRERELEASE"),
    139: .same(proto: "PLAYLIST_ATTRIBUTES_V2"),
    140: .same(proto: "LIST_ATTRIBUTES_V2"),
    141: .same(proto: "LIST_METADATA"),
    142: .same(proto: "LIST_TUNER_AUDIO_ANALYSIS"),
    143: .same(proto: "LIST_TUNER_CUEPOINTS"),
    144: .same(proto: "CONTENT_RATING_TRAIT"),
    145: .same(proto: "COPYRIGHT_TRAIT"),
    146: .same(proto: "SUPPORTED_BADGES"),
    147: .same(proto: "BADGES"),
    148: .same(proto: "PREVIEW_TRAIT"),
    149: .same(proto: "ROOTLISTABILITY_TRAIT"),
    150: .same(proto: "LOCAL_CONCERTS"),
    151: .same(proto: "RECOMMENDED_PLAYLISTS"),
    152: .same(proto: "POPULAR_RELEASES"),
    153: .same(proto: "RELATED_RELEASES"),
    154: .same(proto: "SHARE_RESTRICTIONS"),
    155: .same(proto: "CONCERT_OFFER"),
    156: .same(proto: "CONCERT_OFFER_PROVIDER"),
    157: .same(proto: "ENTITY_BOOKMARKS"),
    158: .same(proto: "PRIVACY_TRAIT"),
    159: .same(proto: "DUPLICATE_ITEMS_TRAIT"),
    160: .same(proto: "REORDERING_TRAIT"),
    161: .same(proto: "PODCAST_RESUMPTION_SEGMENTS"),
    162: .same(proto: "ARTIST_EXPRESSION_VIDEO"),
    163: .same(proto: "PRERELEASE_VIDEO"),
    164: .same(proto: "GATED_ENTITY_RELATIONS"),
    165: .same(proto: "RELATED_CREATORS_SECTION"),
    166: .same(proto: "CREATORS_APPEARS_ON_SECTION"),
    167: .same(proto: "PROMO_V1_TRAIT"),
    168: .same(proto: "SPEECHLESS_SHARE_CARD"),
    169: .same(proto: "TOP_PLAYABLES_SECTION"),
    170: .same(proto: "AUTO_LENS"),
    171: .same(proto: "PROMO_V3_TRAIT"),
    172: .same(proto: "TRACK_CONTENT_FILTER"),
    173: .same(proto: "HIGHLIGHTABILITY"),
    174: .same(proto: "LINK_CARD_WITH_IMAGE_TRAIT"),
    175: .same(proto: "TRACK_CLOUD_SECTION"),
    176: .same(proto: "EPISODE_TOPICS"),
    177: .same(proto: "VIDEO_THUMBNAIL"),
    178: .same(proto: "IDENTITY_TRAIT"),
    179: .same(proto: "VISUAL_IDENTITY_TRAIT"),
    180: .same(proto: "CONTENT_TYPE_V2_TRAIT"),
    181: .same(proto: "PREVIEW_PLAYBACK_TRAIT"),
    182: .same(proto: "CONSUMPTION_EXPERIENCE_TRAIT"),
    183: .same(proto: "PUBLISHING_METADATA_TRAIT"),
    184: .same(proto: "DETAILED_EVALUATION_TRAIT"),
    185: .same(proto: "ON_PLATFORM_REPUTATION_TRAIT"),
    186: .same(proto: "CREDITS_V2_TRAIT"),
    187: .same(proto: "HIGHLIGHT_PLAYABILITY_TRAIT"),
    188: .same(proto: "SHOW_EPISODE_LIST"),
    189: .same(proto: "AVAILABLE_RELEASES"),
    190: .same(proto: "PLAYLIST_DESCRIPTORS"),
    191: .same(proto: "LINK_CARD_WITH_ANIMATIONS_TRAIT"),
    192: .same(proto: "RECAP"),
    193: .same(proto: "AUDIOBOOK_COMPANION_CONTENT"),
    194: .same(proto: "THREE_OH_THREE_PLAY_TRAIT"),
    195: .same(proto: "ARTIST_WRAPPED_2024_VIDEO"),
    196: .same(proto: "CONTAINED_CONTENT_TYPES"),
    197: .same(proto: "CONTENT_CLASSIFICATION"),
    198: .same(proto: "CHAPTER_SPECIFICS"),
    199: .same(proto: "CREATOR_FAN_FUNDING"),
    200: .same(proto: "CREATOR_PLAYLISTS_SECTION"),
    201: .same(proto: "CREATOR_PINNED_ITEM"),
    202: .same(proto: "PODCAST_POLL_V2"),
    203: .same(proto: "CREATOR_APPEARS_ON_SECTION"),
    204: .same(proto: "ARTIST_CONCERTS"),
    205: .same(proto: "LIST_METADATA_V2"),
    206: .same(proto: "ARTIST_HEADLINE"),
    207: .same(proto: "EPISODE_AD_PLACEMENTS"),
    208: .same(proto: "VIDEO_SOCIAL_PROOF_POC_TRAIT"),
    209: .same(proto: "ARTIST_MUSIC_VIDEOS"),
    210: .same(proto: "ARTIST_LISTENING_PARTY"),
    211: .same(proto: "CONTENT_BY_OR_ABOUT"),
    212: .same(proto: "PLAYBACK_TRAIT"),
    213: .same(proto: "ARTIST_MUSIC_VIDEOS_UNMAPPED"),
    214: .same(proto: "ENTITY_CONNECTIONS"),
    215: .same(proto: "USER_PROFILE_V2"),
  ]
}

extension SPMetaBatchedEntityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchedEntityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.request.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.request, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaBatchedEntityRequest, rhs: SPMetaBatchedEntityRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaBatchedEntityRequestHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchedEntityRequestHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "country"),
    2: .same(proto: "catalogue"),
    3: .standard(proto: "task_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.catalogue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taskID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 1)
    }
    if !self.catalogue.isEmpty {
      try visitor.visitSingularStringField(value: self.catalogue, fieldNumber: 2)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaBatchedEntityRequestHeader, rhs: SPMetaBatchedEntityRequestHeader) -> Bool {
    if lhs.country != rhs.country {return false}
    if lhs.catalogue != rhs.catalogue {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaEntityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "query"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.query) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaEntityRequest, rhs: SPMetaEntityRequest) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaExtensionQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtensionQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "etag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._etag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unknownExtension {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._etag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaExtensionQuery, rhs: SPMetaExtensionQuery) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._etag != rhs._etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaBatchedExtensionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchedExtensionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "extended_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.extendedMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.extendedMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extendedMetadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaBatchedExtensionResponse, rhs: SPMetaBatchedExtensionResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.extendedMetadata != rhs.extendedMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaBatchedExtensionResponseHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchedExtensionResponseHeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaBatchedExtensionResponseHeader, rhs: SPMetaBatchedExtensionResponseHeader) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaEntityExtensionDataArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityExtensionDataArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "kind"),
    3: .standard(proto: "extension_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.extensionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.kind != .unknownExtension {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.extensionData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensionData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaEntityExtensionDataArray, rhs: SPMetaEntityExtensionDataArray) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.extensionData != rhs.extensionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaEntityExtensionDataArrayHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityExtensionDataArrayHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_error_status"),
    2: .standard(proto: "cache_ttl_in_seconds"),
    3: .standard(proto: "offline_ttl_in_seconds"),
    4: .standard(proto: "extension_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.providerErrorStatus) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.cacheTtlInSeconds) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.offlineTtlInSeconds) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.extensionType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.providerErrorStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.providerErrorStatus, fieldNumber: 1)
    }
    if self.cacheTtlInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.cacheTtlInSeconds, fieldNumber: 2)
    }
    if self.offlineTtlInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.offlineTtlInSeconds, fieldNumber: 3)
    }
    if self.extensionType != .unknown {
      try visitor.visitSingularEnumField(value: self.extensionType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaEntityExtensionDataArrayHeader, rhs: SPMetaEntityExtensionDataArrayHeader) -> Bool {
    if lhs.providerErrorStatus != rhs.providerErrorStatus {return false}
    if lhs.cacheTtlInSeconds != rhs.cacheTtlInSeconds {return false}
    if lhs.offlineTtlInSeconds != rhs.offlineTtlInSeconds {return false}
    if lhs.extensionType != rhs.extensionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaEntityExtensionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityExtensionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "entity_uri"),
    3: .standard(proto: "extension_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityUri) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._extensionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entityUri.isEmpty {
      try visitor.visitSingularStringField(value: self.entityUri, fieldNumber: 2)
    }
    try { if let v = self._extensionData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaEntityExtensionData, rhs: SPMetaEntityExtensionData) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.entityUri != rhs.entityUri {return false}
    if lhs._extensionData != rhs._extensionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaEntityExtensionDataHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityExtensionDataHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code"),
    2: .same(proto: "etag"),
    3: .same(proto: "locale"),
    4: .standard(proto: "cache_ttl_in_seconds"),
    5: .standard(proto: "offline_ttl_in_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.statusCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.cacheTtlInSeconds) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.offlineTtlInSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusCode != 0 {
      try visitor.visitSingularInt32Field(value: self.statusCode, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 3)
    }
    if self.cacheTtlInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.cacheTtlInSeconds, fieldNumber: 4)
    }
    if self.offlineTtlInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.offlineTtlInSeconds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaEntityExtensionDataHeader, rhs: SPMetaEntityExtensionDataHeader) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs.cacheTtlInSeconds != rhs.cacheTtlInSeconds {return false}
    if lhs.offlineTtlInSeconds != rhs.offlineTtlInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaPlainListAssoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlainListAssoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.entityUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityUri.isEmpty {
      try visitor.visitRepeatedStringField(value: self.entityUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaPlainListAssoc, rhs: SPMetaPlainListAssoc) -> Bool {
    if lhs.entityUri != rhs.entityUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaAssocHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssocHeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaAssocHeader, rhs: SPMetaAssocHeader) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetaAssoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Assoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "plain_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._plainList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._plainList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPMetaAssoc, rhs: SPMetaAssoc) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._plainList != rhs._plainList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
