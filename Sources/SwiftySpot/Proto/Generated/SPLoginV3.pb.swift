// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SPLoginV3.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Requests
struct SPLoginV3Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: SPShortClientInfo {
    get {return _client ?? SPShortClientInfo()}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  mutating func clearClient() {self._client = nil}

  var context: Data {
    get {return _context ?? Data()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var answerData: LoginChallengeAnswerData {
    get {return _answerData ?? LoginChallengeAnswerData()}
    set {_answerData = newValue}
  }
  /// Returns true if `answerData` has been explicitly set.
  var hasAnswerData: Bool {return self._answerData != nil}
  /// Clears the value of `answerData`. Subsequent reads from it will return its default value.
  mutating func clearAnswerData() {self._answerData = nil}

  var request: SPLoginV3Request.OneOf_Request? = nil

  var stored: SPStoredCredential {
    get {
      if case .stored(let v)? = request {return v}
      return SPStoredCredential()
    }
    set {request = .stored(newValue)}
  }

  var password: SPPassword {
    get {
      if case .password(let v)? = request {return v}
      return SPPassword()
    }
    set {request = .password(newValue)}
  }

  var facebook: FacebookAccessToken {
    get {
      if case .facebook(let v)? = request {return v}
      return FacebookAccessToken()
    }
    set {request = .facebook(newValue)}
  }

  var phone: PhoneNumber {
    get {
      if case .phone(let v)? = request {return v}
      return PhoneNumber()
    }
    set {request = .phone(newValue)}
  }

  var oneTimeToken: SPOneTimeToken {
    get {
      if case .oneTimeToken(let v)? = request {return v}
      return SPOneTimeToken()
    }
    set {request = .oneTimeToken(newValue)}
  }

  var parentChildCred: SPParentChildCredential {
    get {
      if case .parentChildCred(let v)? = request {return v}
      return SPParentChildCredential()
    }
    set {request = .parentChildCred(newValue)}
  }

  var appleSignIn: AppleSignInCredential {
    get {
      if case .appleSignIn(let v)? = request {return v}
      return AppleSignInCredential()
    }
    set {request = .appleSignIn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case stored(SPStoredCredential)
    case password(SPPassword)
    case facebook(FacebookAccessToken)
    case phone(PhoneNumber)
    case oneTimeToken(SPOneTimeToken)
    case parentChildCred(SPParentChildCredential)
    case appleSignIn(AppleSignInCredential)

  #if !swift(>=4.1)
    static func ==(lhs: SPLoginV3Request.OneOf_Request, rhs: SPLoginV3Request.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stored, .stored): return {
        guard case .stored(let l) = lhs, case .stored(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.password, .password): return {
        guard case .password(let l) = lhs, case .password(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.facebook, .facebook): return {
        guard case .facebook(let l) = lhs, case .facebook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.phone, .phone): return {
        guard case .phone(let l) = lhs, case .phone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oneTimeToken, .oneTimeToken): return {
        guard case .oneTimeToken(let l) = lhs, case .oneTimeToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.parentChildCred, .parentChildCred): return {
        guard case .parentChildCred(let l) = lhs, case .parentChildCred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appleSignIn, .appleSignIn): return {
        guard case .appleSignIn(let l) = lhs, case .appleSignIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _client: SPShortClientInfo? = nil
  fileprivate var _context: Data? = nil
  fileprivate var _answerData: LoginChallengeAnswerData? = nil
}

struct PhoneNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: String = String()

  var isoCountryCode: String = String()

  var countryCallingCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginChallengeAnswerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answers: [LoginChallengeAnswer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginChallengeAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answer: LoginChallengeAnswer.OneOf_Answer? = nil

  var hashcash: HashcashAnswer {
    get {
      if case .hashcash(let v)? = answer {return v}
      return HashcashAnswer()
    }
    set {answer = .hashcash(newValue)}
  }

  var code: LoginCodeAnswer {
    get {
      if case .code(let v)? = answer {return v}
      return LoginCodeAnswer()
    }
    set {answer = .code(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Answer: Equatable {
    case hashcash(HashcashAnswer)
    case code(LoginCodeAnswer)

  #if !swift(>=4.1)
    static func ==(lhs: LoginChallengeAnswer.OneOf_Answer, rhs: LoginChallengeAnswer.OneOf_Answer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hashcash, .hashcash): return {
        guard case .hashcash(let l) = lhs, case .hashcash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.code, .code): return {
        guard case .code(let l) = lhs, case .code(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct HashcashAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suffix: Data = Data()

  var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct LoginCodeAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Responses
struct SPLoginV3Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: SPLoginV3Response.OneOf_Response? = nil

  var auth: SPAuthToken {
    get {
      if case .auth(let v)? = response {return v}
      return SPAuthToken()
    }
    set {response = .auth(newValue)}
  }

  var error: SPLoginV3Response.Error {
    get {
      if case .error(let v)? = response {return v}
      return .unknownError
    }
    set {response = .error(newValue)}
  }

  var challenge: LoginChallengesData {
    get {
      if case .challenge(let v)? = response {return v}
      return LoginChallengesData()
    }
    set {response = .challenge(newValue)}
  }

  ///intern tip: repeated is already optional
  var warnings: [SPLoginV3Response.Warning] = []

  var context: Data {
    get {return _context ?? Data()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var idToken: String {
    get {return _idToken ?? String()}
    set {_idToken = newValue}
  }
  /// Returns true if `idToken` has been explicitly set.
  var hasIDToken: Bool {return self._idToken != nil}
  /// Clears the value of `idToken`. Subsequent reads from it will return its default value.
  mutating func clearIDToken() {self._idToken = nil}

  var userInfo: UserInfo {
    get {return _userInfo ?? UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {self._userInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case auth(SPAuthToken)
    case error(SPLoginV3Response.Error)
    case challenge(LoginChallengesData)

  #if !swift(>=4.1)
    static func ==(lhs: SPLoginV3Response.OneOf_Response, rhs: SPLoginV3Response.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.auth, .auth): return {
        guard case .auth(let l) = lhs, case .auth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challenge, .challenge): return {
        guard case .challenge(let l) = lhs, case .challenge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Warning: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownWarning // = 0
    case deprecatedProtocolVersion // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownWarning
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownWarning
      case 1: self = .deprecatedProtocolVersion
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownWarning: return 0
      case .deprecatedProtocolVersion: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownError // = 0
    case invalidCredentials // = 1
    case badRequest // = 2
    case unsupportedLoginProtocol // = 3
    case timeout // = 4
    case unknownIdentifier // = 5
    case tooManyAttempts // = 6
    case invalidPhonenumber // = 7
    case tryAgainLater // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      case 1: self = .invalidCredentials
      case 2: self = .badRequest
      case 3: self = .unsupportedLoginProtocol
      case 4: self = .timeout
      case 5: self = .unknownIdentifier
      case 6: self = .tooManyAttempts
      case 7: self = .invalidPhonenumber
      case 8: self = .tryAgainLater
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .invalidCredentials: return 1
      case .badRequest: return 2
      case .unsupportedLoginProtocol: return 3
      case .timeout: return 4
      case .unknownIdentifier: return 5
      case .tooManyAttempts: return 6
      case .invalidPhonenumber: return 7
      case .tryAgainLater: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _context: Data? = nil
  fileprivate var _idToken: String? = nil
  fileprivate var _userInfo: UserInfo? = nil
}

#if swift(>=4.2)

extension SPLoginV3Response.Warning: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPLoginV3Response.Warning] = [
    .unknownWarning,
    .deprecatedProtocolVersion,
  ]
}

extension SPLoginV3Response.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPLoginV3Response.Error] = [
    .unknownError,
    .invalidCredentials,
    .badRequest,
    .unsupportedLoginProtocol,
    .timeout,
    .unknownIdentifier,
    .tooManyAttempts,
    .invalidPhonenumber,
    .tryAgainLater,
  ]
}

#endif  // swift(>=4.2)

struct SPAuthToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var token: String = String()

  var storedCredential: Data = Data()

  var expiresInS: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var email: String = String()

  var emailVerified: Bool = false

  var birthdate: String = String()

  var gender: UserInfo.Gender = .unknown

  var phone: String = String()

  var phoneVerified: Bool = false

  var emailAlredyRegistered: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Gender: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case male // = 1
    case female // = 2
    case neutral // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .male
      case 2: self = .female
      case 3: self = .neutral
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .male: return 1
      case .female: return 2
      case .neutral: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension UserInfo.Gender: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UserInfo.Gender] = [
    .unknown,
    .male,
    .female,
    .neutral,
  ]
}

#endif  // swift(>=4.2)

struct LoginChallengesData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var challenges: [LoginChallenge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var method: LoginChallenge.OneOf_Method? = nil

  var hashcash: LoginHashcashChallenge {
    get {
      if case .hashcash(let v)? = method {return v}
      return LoginHashcashChallenge()
    }
    set {method = .hashcash(newValue)}
  }

  var code: LoginCodeChallenge {
    get {
      if case .code(let v)? = method {return v}
      return LoginCodeChallenge()
    }
    set {method = .code(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Method: Equatable {
    case hashcash(LoginHashcashChallenge)
    case code(LoginCodeChallenge)

  #if !swift(>=4.1)
    static func ==(lhs: LoginChallenge.OneOf_Method, rhs: LoginChallenge.OneOf_Method) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hashcash, .hashcash): return {
        guard case .hashcash(let l) = lhs, case .hashcash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.code, .code): return {
        guard case .code(let l) = lhs, case .code(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct LoginHashcashChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prefix: Data = Data()

  var length: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginCodeChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var method: LoginCodeChallenge.Method = .unknown

  var length: Int32 = 0

  var expiresInS: Int32 = 0

  var phone: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Method: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case sms // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sms
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sms: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension LoginCodeChallenge.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LoginCodeChallenge.Method] = [
    .unknown,
    .sms,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension SPLoginV3Request: @unchecked Sendable {}
extension SPLoginV3Request.OneOf_Request: @unchecked Sendable {}
extension PhoneNumber: @unchecked Sendable {}
extension LoginChallengeAnswerData: @unchecked Sendable {}
extension LoginChallengeAnswer: @unchecked Sendable {}
extension LoginChallengeAnswer.OneOf_Answer: @unchecked Sendable {}
extension HashcashAnswer: @unchecked Sendable {}
extension LoginCodeAnswer: @unchecked Sendable {}
extension SPLoginV3Response: @unchecked Sendable {}
extension SPLoginV3Response.OneOf_Response: @unchecked Sendable {}
extension SPLoginV3Response.Warning: @unchecked Sendable {}
extension SPLoginV3Response.Error: @unchecked Sendable {}
extension SPAuthToken: @unchecked Sendable {}
extension UserInfo: @unchecked Sendable {}
extension UserInfo.Gender: @unchecked Sendable {}
extension LoginChallengesData: @unchecked Sendable {}
extension LoginChallenge: @unchecked Sendable {}
extension LoginChallenge.OneOf_Method: @unchecked Sendable {}
extension LoginHashcashChallenge: @unchecked Sendable {}
extension LoginCodeChallenge: @unchecked Sendable {}
extension LoginCodeChallenge.Method: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SPLoginV3Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPLoginV3Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "context"),
    3: .same(proto: "answerData"),
    100: .same(proto: "stored"),
    101: .same(proto: "password"),
    102: .same(proto: "facebook"),
    103: .same(proto: "phone"),
    104: .same(proto: "oneTimeToken"),
    105: .same(proto: "parentChildCred"),
    106: .same(proto: "appleSignIn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._client) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._answerData) }()
      case 100: try {
        var v: SPStoredCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .stored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .stored(v)
        }
      }()
      case 101: try {
        var v: SPPassword?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .password(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .password(v)
        }
      }()
      case 102: try {
        var v: FacebookAccessToken?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .facebook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .facebook(v)
        }
      }()
      case 103: try {
        var v: PhoneNumber?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .phone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .phone(v)
        }
      }()
      case 104: try {
        var v: SPOneTimeToken?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .oneTimeToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .oneTimeToken(v)
        }
      }()
      case 105: try {
        var v: SPParentChildCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .parentChildCred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .parentChildCred(v)
        }
      }()
      case 106: try {
        var v: AppleSignInCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .appleSignIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .appleSignIn(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._client {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._answerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.request {
    case .stored?: try {
      guard case .stored(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .password?: try {
      guard case .password(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .facebook?: try {
      guard case .facebook(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .phone?: try {
      guard case .phone(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .oneTimeToken?: try {
      guard case .oneTimeToken(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .parentChildCred?: try {
      guard case .parentChildCred(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .appleSignIn?: try {
      guard case .appleSignIn(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginV3Request, rhs: SPLoginV3Request) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs._context != rhs._context {return false}
    if lhs._answerData != rhs._answerData {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PhoneNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PhoneNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "isoCountryCode"),
    3: .same(proto: "countryCallingCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.isoCountryCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCallingCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 1)
    }
    if !self.isoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.isoCountryCode, fieldNumber: 2)
    }
    if !self.countryCallingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCallingCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PhoneNumber, rhs: PhoneNumber) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs.isoCountryCode != rhs.isoCountryCode {return false}
    if lhs.countryCallingCode != rhs.countryCallingCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginChallengeAnswerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengeAnswerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginChallengeAnswerData, rhs: LoginChallengeAnswerData) -> Bool {
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginChallengeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashcash"),
    2: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: HashcashAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .hashcash(v)
        }
      }()
      case 2: try {
        var v: LoginCodeAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .code(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .code(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.answer {
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .code?: try {
      guard case .code(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginChallengeAnswer, rhs: LoginChallengeAnswer) -> Bool {
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HashcashAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashcashAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "suffix"),
    2: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.suffix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.suffix.isEmpty {
      try visitor.visitSingularBytesField(value: self.suffix, fieldNumber: 1)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HashcashAnswer, rhs: HashcashAnswer) -> Bool {
    if lhs.suffix != rhs.suffix {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginCodeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginCodeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.val) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginCodeAnswer, rhs: LoginCodeAnswer) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginV3Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPLoginV3Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "error"),
    3: .same(proto: "challenge"),
    4: .same(proto: "warnings"),
    5: .same(proto: "context"),
    6: .same(proto: "idToken"),
    7: .same(proto: "userInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SPAuthToken?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .auth(v)
        }
      }()
      case 2: try {
        var v: SPLoginV3Response.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: LoginChallengesData?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .challenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .challenge(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.warnings) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._context) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._idToken) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .auth?: try {
      guard case .auth(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .challenge?: try {
      guard case .challenge(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.warnings.isEmpty {
      try visitor.visitPackedEnumField(value: self.warnings, fieldNumber: 4)
    }
    try { if let v = self._context {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._idToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginV3Response, rhs: SPLoginV3Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs._context != rhs._context {return false}
    if lhs._idToken != rhs._idToken {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginV3Response.Warning: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WARNING"),
    1: .same(proto: "DEPRECATED_PROTOCOL_VERSION"),
  ]
}

extension SPLoginV3Response.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "INVALID_CREDENTIALS"),
    2: .same(proto: "BAD_REQUEST"),
    3: .same(proto: "UNSUPPORTED_LOGIN_PROTOCOL"),
    4: .same(proto: "TIMEOUT"),
    5: .same(proto: "UNKNOWN_IDENTIFIER"),
    6: .same(proto: "TOO_MANY_ATTEMPTS"),
    7: .same(proto: "INVALID_PHONENUMBER"),
    8: .same(proto: "TRY_AGAIN_LATER"),
  ]
}

extension SPAuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPAuthToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "token"),
    3: .same(proto: "storedCredential"),
    4: .same(proto: "expiresInS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.storedCredential) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.storedCredential.isEmpty {
      try visitor.visitSingularBytesField(value: self.storedCredential, fieldNumber: 3)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPAuthToken, rhs: SPAuthToken) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.token != rhs.token {return false}
    if lhs.storedCredential != rhs.storedCredential {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "email"),
    3: .same(proto: "emailVerified"),
    4: .same(proto: "birthdate"),
    5: .same(proto: "gender"),
    6: .same(proto: "phone"),
    7: .same(proto: "phoneVerified"),
    8: .same(proto: "emailAlredyRegistered"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.emailVerified) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.birthdate) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.phoneVerified) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.emailAlredyRegistered) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.emailVerified != false {
      try visitor.visitSingularBoolField(value: self.emailVerified, fieldNumber: 3)
    }
    if !self.birthdate.isEmpty {
      try visitor.visitSingularStringField(value: self.birthdate, fieldNumber: 4)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 5)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 6)
    }
    if self.phoneVerified != false {
      try visitor.visitSingularBoolField(value: self.phoneVerified, fieldNumber: 7)
    }
    if self.emailAlredyRegistered != false {
      try visitor.visitSingularBoolField(value: self.emailAlredyRegistered, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserInfo, rhs: UserInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.email != rhs.email {return false}
    if lhs.emailVerified != rhs.emailVerified {return false}
    if lhs.birthdate != rhs.birthdate {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.phoneVerified != rhs.phoneVerified {return false}
    if lhs.emailAlredyRegistered != rhs.emailAlredyRegistered {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserInfo.Gender: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "MALE"),
    2: .same(proto: "FEMALE"),
    3: .same(proto: "NEUTRAL"),
  ]
}

extension LoginChallengesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengesData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.challenges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.challenges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginChallengesData, rhs: LoginChallengesData) -> Bool {
    if lhs.challenges != rhs.challenges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashcash"),
    2: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: LoginHashcashChallenge?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .hashcash(v)
        }
      }()
      case 2: try {
        var v: LoginCodeChallenge?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .code(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .code(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.method {
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .code?: try {
      guard case .code(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginChallenge, rhs: LoginChallenge) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginHashcashChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginHashcashChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginHashcashChallenge, rhs: LoginHashcashChallenge) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginCodeChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginCodeChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "length"),
    3: .same(proto: "expiresInS"),
    4: .same(proto: "phone"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.method != .unknown {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 2)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 3)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginCodeChallenge, rhs: LoginCodeChallenge) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.length != rhs.length {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginCodeChallenge.Method: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMS"),
  ]
}
