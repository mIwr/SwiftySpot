// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SPConnectivity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SPConnectivity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: PlatformSpecificData {
    get {return _platform ?? PlatformSpecificData()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  mutating func clearPlatform() {self._platform = nil}

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _platform: PlatformSpecificData? = nil
}

struct PlatformSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: PlatformSpecificData.OneOf_Data? = nil

  var android: NativeAndroidData {
    get {
      if case .android(let v)? = data {return v}
      return NativeAndroidData()
    }
    set {data = .android(newValue)}
  }

  var ios: NativeIOSData {
    get {
      if case .ios(let v)? = data {return v}
      return NativeIOSData()
    }
    set {data = .ios(newValue)}
  }

  var windows: NativeWindowsData {
    get {
      if case .windows(let v)? = data {return v}
      return NativeWindowsData()
    }
    set {data = .windows(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case android(NativeAndroidData)
    case ios(NativeIOSData)
    case windows(NativeWindowsData)

  #if !swift(>=4.1)
    static func ==(lhs: PlatformSpecificData.OneOf_Data, rhs: PlatformSpecificData.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.android, .android): return {
        guard case .android(let l) = lhs, case .android(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ios, .ios): return {
        guard case .ios(let l) = lhs, case .ios(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windows, .windows): return {
        guard case .windows(let l) = lhs, case .windows(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct NativeAndroidData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screen: SPScreenInfo {
    get {return _screen ?? SPScreenInfo()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  mutating func clearScreen() {self._screen = nil}

  var osVer: String = String()

  var sdk: Int32 = 0

  var model: String = String()

  var model2: String = String()

  var brand: String = String()

  var brand2: String = String()

  var aarch: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _screen: SPScreenInfo? = nil
}

struct NativeIOSData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userInterfaceIdiom: Int32 = 0

  var simulator: Bool = false

  var hw: String = String()

  var osVer: String = String()

  var model: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NativeWindowsData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var something1: Int32 = 0

  var something3: Int32 = 0

  var something4: Int32 = 0

  var something6: Int32 = 0

  var something7: Int32 = 0

  var something8: Int32 = 0

  var something10: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPScreenInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Int32 = 0

  var height: Int32 = 0

  var density: Int32 = 0

  var densityOther: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SPConnectivity: @unchecked Sendable {}
extension PlatformSpecificData: @unchecked Sendable {}
extension PlatformSpecificData.OneOf_Data: @unchecked Sendable {}
extension NativeAndroidData: @unchecked Sendable {}
extension NativeIOSData: @unchecked Sendable {}
extension NativeWindowsData: @unchecked Sendable {}
extension SPScreenInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SPConnectivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPConnectivity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPConnectivity, rhs: SPConnectivity) -> Bool {
    if lhs._platform != rhs._platform {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PlatformSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PlatformSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "android"),
    2: .same(proto: "ios"),
    4: .same(proto: "windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: NativeAndroidData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .android(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .android(v)
        }
      }()
      case 2: try {
        var v: NativeIOSData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ios(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ios(v)
        }
      }()
      case 4: try {
        var v: NativeWindowsData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .windows(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .windows(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .android?: try {
      guard case .android(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ios?: try {
      guard case .ios(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .windows?: try {
      guard case .windows(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PlatformSpecificData, rhs: PlatformSpecificData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NativeAndroidData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NativeAndroidData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screen"),
    2: .same(proto: "osVer"),
    3: .same(proto: "sdk"),
    4: .same(proto: "model"),
    5: .same(proto: "model2"),
    6: .same(proto: "brand"),
    7: .same(proto: "brand2"),
    8: .same(proto: "aarch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVer) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sdk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.model2) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.brand2) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.aarch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.osVer.isEmpty {
      try visitor.visitSingularStringField(value: self.osVer, fieldNumber: 2)
    }
    if self.sdk != 0 {
      try visitor.visitSingularInt32Field(value: self.sdk, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.model2.isEmpty {
      try visitor.visitSingularStringField(value: self.model2, fieldNumber: 5)
    }
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 6)
    }
    if !self.brand2.isEmpty {
      try visitor.visitSingularStringField(value: self.brand2, fieldNumber: 7)
    }
    if self.aarch != 0 {
      try visitor.visitSingularInt32Field(value: self.aarch, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NativeAndroidData, rhs: NativeAndroidData) -> Bool {
    if lhs._screen != rhs._screen {return false}
    if lhs.osVer != rhs.osVer {return false}
    if lhs.sdk != rhs.sdk {return false}
    if lhs.model != rhs.model {return false}
    if lhs.model2 != rhs.model2 {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.brand2 != rhs.brand2 {return false}
    if lhs.aarch != rhs.aarch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NativeIOSData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NativeIOSData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInterfaceIdiom"),
    2: .same(proto: "simulator"),
    3: .same(proto: "hw"),
    4: .same(proto: "osVer"),
    5: .same(proto: "model"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userInterfaceIdiom) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.simulator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hw) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osVer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.model) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userInterfaceIdiom != 0 {
      try visitor.visitSingularInt32Field(value: self.userInterfaceIdiom, fieldNumber: 1)
    }
    if self.simulator != false {
      try visitor.visitSingularBoolField(value: self.simulator, fieldNumber: 2)
    }
    if !self.hw.isEmpty {
      try visitor.visitSingularStringField(value: self.hw, fieldNumber: 3)
    }
    if !self.osVer.isEmpty {
      try visitor.visitSingularStringField(value: self.osVer, fieldNumber: 4)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NativeIOSData, rhs: NativeIOSData) -> Bool {
    if lhs.userInterfaceIdiom != rhs.userInterfaceIdiom {return false}
    if lhs.simulator != rhs.simulator {return false}
    if lhs.hw != rhs.hw {return false}
    if lhs.osVer != rhs.osVer {return false}
    if lhs.model != rhs.model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NativeWindowsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NativeWindowsData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "something1"),
    3: .same(proto: "something3"),
    4: .same(proto: "something4"),
    6: .same(proto: "something6"),
    7: .same(proto: "something7"),
    8: .same(proto: "something8"),
    10: .same(proto: "something10"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.something1) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.something3) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.something4) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.something6) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.something7) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.something8) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.something10) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.something1 != 0 {
      try visitor.visitSingularInt32Field(value: self.something1, fieldNumber: 1)
    }
    if self.something3 != 0 {
      try visitor.visitSingularInt32Field(value: self.something3, fieldNumber: 3)
    }
    if self.something4 != 0 {
      try visitor.visitSingularInt32Field(value: self.something4, fieldNumber: 4)
    }
    if self.something6 != 0 {
      try visitor.visitSingularInt32Field(value: self.something6, fieldNumber: 6)
    }
    if self.something7 != 0 {
      try visitor.visitSingularInt32Field(value: self.something7, fieldNumber: 7)
    }
    if self.something8 != 0 {
      try visitor.visitSingularInt32Field(value: self.something8, fieldNumber: 8)
    }
    if self.something10 != false {
      try visitor.visitSingularBoolField(value: self.something10, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NativeWindowsData, rhs: NativeWindowsData) -> Bool {
    if lhs.something1 != rhs.something1 {return false}
    if lhs.something3 != rhs.something3 {return false}
    if lhs.something4 != rhs.something4 {return false}
    if lhs.something6 != rhs.something6 {return false}
    if lhs.something7 != rhs.something7 {return false}
    if lhs.something8 != rhs.something8 {return false}
    if lhs.something10 != rhs.something10 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPScreenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPScreenInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "density"),
    4: .same(proto: "densityOther"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.density) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.densityOther) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.density != 0 {
      try visitor.visitSingularInt32Field(value: self.density, fieldNumber: 3)
    }
    if self.densityOther != 0 {
      try visitor.visitSingularInt32Field(value: self.densityOther, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPScreenInfo, rhs: SPScreenInfo) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.density != rhs.density {return false}
    if lhs.densityOther != rhs.densityOther {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
