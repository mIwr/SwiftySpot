// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Search.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SPSearchAutocompleteViewResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hits: [SPSearchResultEntity] = []

  var autocompleteQueries: [SPSearchAutocompleteQuery] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPSearchMainViewResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hits: [SPSearchResultEntity] = []

  var recommendations: SPSearchRecommendations {
    get {return _recommendations ?? SPSearchRecommendations()}
    set {_recommendations = newValue}
  }
  /// Returns true if `recommendations` has been explicitly set.
  var hasRecommendations: Bool {return self._recommendations != nil}
  /// Clears the value of `recommendations`. Subsequent reads from it will return its default value.
  mutating func clearRecommendations() {self._recommendations = nil}

  var entityTypes: Data = Data()

  var nextPageToken: String {
    get {return _nextPageToken ?? String()}
    set {_nextPageToken = newValue}
  }
  /// Returns true if `nextPageToken` has been explicitly set.
  var hasNextPageToken: Bool {return self._nextPageToken != nil}
  /// Clears the value of `nextPageToken`. Subsequent reads from it will return its default value.
  mutating func clearNextPageToken() {self._nextPageToken = nil}

  var banner: SPBannerContent {
    get {return _banner ?? SPBannerContent()}
    set {_banner = newValue}
  }
  /// Returns true if `banner` has been explicitly set.
  var hasBanner: Bool {return self._banner != nil}
  /// Clears the value of `banner`. Subsequent reads from it will return its default value.
  mutating func clearBanner() {self._banner = nil}

  var relatedSearches: [SPSearchRelated] = []

  var autocompleteQueries: [SPSearchAutocompleteQuery] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recommendations: SPSearchRecommendations? = nil
  fileprivate var _nextPageToken: String? = nil
  fileprivate var _banner: SPBannerContent? = nil
}

struct SPSearchRecommendations: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Int32 = 0

  var entities: [SPSearchResultEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPSearchResultEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var name: String = String()

  var imageUri: String = String()

  var info: SPSearchResultEntity.OneOf_Info? = nil

  var artist: SPSearchArtist {
    get {
      if case .artist(let v)? = info {return v}
      return SPSearchArtist()
    }
    set {info = .artist(newValue)}
  }

  var track: SPSearchTrack {
    get {
      if case .track(let v)? = info {return v}
      return SPSearchTrack()
    }
    set {info = .track(newValue)}
  }

  var album: SPSearchAlbum {
    get {
      if case .album(let v)? = info {return v}
      return SPSearchAlbum()
    }
    set {info = .album(newValue)}
  }

  var playlist: SPSearchPlaylist {
    get {
      if case .playlist(let v)? = info {return v}
      return SPSearchPlaylist()
    }
    set {info = .playlist(newValue)}
  }

  var genre: SPSearchGenre {
    get {
      if case .genre(let v)? = info {return v}
      return SPSearchGenre()
    }
    set {info = .genre(newValue)}
  }

  var show: SPSearchAudioShow {
    get {
      if case .show(let v)? = info {return v}
      return SPSearchAudioShow()
    }
    set {info = .show(newValue)}
  }

  var profile: SPSearchProfile {
    get {
      if case .profile(let v)? = info {return v}
      return SPSearchProfile()
    }
    set {info = .profile(newValue)}
  }

  var audiobook: SPSearchAudiobook {
    get {
      if case .audiobook(let v)? = info {return v}
      return SPSearchAudiobook()
    }
    set {info = .audiobook(newValue)}
  }

  var autocompleteQuery: SPSearchAutocompleteQuery {
    get {
      if case .autocompleteQuery(let v)? = info {return v}
      return SPSearchAutocompleteQuery()
    }
    set {info = .autocompleteQuery(newValue)}
  }

  var serpMetadata: String {
    get {return _serpMetadata ?? String()}
    set {_serpMetadata = newValue}
  }
  /// Returns true if `serpMetadata` has been explicitly set.
  var hasSerpMetadata: Bool {return self._serpMetadata != nil}
  /// Clears the value of `serpMetadata`. Subsequent reads from it will return its default value.
  mutating func clearSerpMetadata() {self._serpMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Info: Equatable, Sendable {
    case artist(SPSearchArtist)
    case track(SPSearchTrack)
    case album(SPSearchAlbum)
    case playlist(SPSearchPlaylist)
    case genre(SPSearchGenre)
    case show(SPSearchAudioShow)
    case profile(SPSearchProfile)
    case audiobook(SPSearchAudiobook)
    case autocompleteQuery(SPSearchAutocompleteQuery)

  }

  init() {}

  fileprivate var _serpMetadata: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.spotify.searchview.proto"

extension SPSearchAutocompleteViewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutocompleteViewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
    1000: .standard(proto: "autocomplete_queries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 1000: try { try decoder.decodeRepeatedMessageField(value: &self.autocompleteQueries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    if !self.autocompleteQueries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.autocompleteQueries, fieldNumber: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPSearchAutocompleteViewResponse, rhs: SPSearchAutocompleteViewResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs.autocompleteQueries != rhs.autocompleteQueries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPSearchMainViewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MainViewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
    2: .same(proto: "recommendations"),
    3: .standard(proto: "entity_types"),
    4: .standard(proto: "next_page_token"),
    5: .same(proto: "banner"),
    6: .standard(proto: "related_searches"),
    7: .standard(proto: "autocomplete_queries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recommendations) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.entityTypes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._nextPageToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._banner) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.relatedSearches) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.autocompleteQueries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    try { if let v = self._recommendations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.entityTypes.isEmpty {
      try visitor.visitSingularBytesField(value: self.entityTypes, fieldNumber: 3)
    }
    try { if let v = self._nextPageToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._banner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.relatedSearches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relatedSearches, fieldNumber: 6)
    }
    if !self.autocompleteQueries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.autocompleteQueries, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPSearchMainViewResponse, rhs: SPSearchMainViewResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs._recommendations != rhs._recommendations {return false}
    if lhs.entityTypes != rhs.entityTypes {return false}
    if lhs._nextPageToken != rhs._nextPageToken {return false}
    if lhs._banner != rhs._banner {return false}
    if lhs.relatedSearches != rhs.relatedSearches {return false}
    if lhs.autocompleteQueries != rhs.autocompleteQueries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPSearchRecommendations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recommendations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "entities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPSearchRecommendations, rhs: SPSearchRecommendations) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.entities != rhs.entities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPSearchResultEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
    3: .standard(proto: "image_uri"),
    4: .same(proto: "artist"),
    5: .same(proto: "track"),
    6: .same(proto: "album"),
    7: .same(proto: "playlist"),
    8: .same(proto: "genre"),
    9: .same(proto: "show"),
    11: .same(proto: "profile"),
    13: .same(proto: "audiobook"),
    2046: .standard(proto: "autocomplete_query"),
    2047: .standard(proto: "serp_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageUri) }()
      case 4: try {
        var v: SPSearchArtist?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .artist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .artist(v)
        }
      }()
      case 5: try {
        var v: SPSearchTrack?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .track(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .track(v)
        }
      }()
      case 6: try {
        var v: SPSearchAlbum?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .album(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .album(v)
        }
      }()
      case 7: try {
        var v: SPSearchPlaylist?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .playlist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .playlist(v)
        }
      }()
      case 8: try {
        var v: SPSearchGenre?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .genre(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .genre(v)
        }
      }()
      case 9: try {
        var v: SPSearchAudioShow?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .show(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .show(v)
        }
      }()
      case 11: try {
        var v: SPSearchProfile?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .profile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .profile(v)
        }
      }()
      case 13: try {
        var v: SPSearchAudiobook?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .audiobook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .audiobook(v)
        }
      }()
      case 2046: try {
        var v: SPSearchAutocompleteQuery?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .autocompleteQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .autocompleteQuery(v)
        }
      }()
      case 2047: try { try decoder.decodeSingularStringField(value: &self._serpMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.imageUri.isEmpty {
      try visitor.visitSingularStringField(value: self.imageUri, fieldNumber: 3)
    }
    switch self.info {
    case .artist?: try {
      guard case .artist(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .track?: try {
      guard case .track(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .album?: try {
      guard case .album(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .playlist?: try {
      guard case .playlist(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .genre?: try {
      guard case .genre(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .show?: try {
      guard case .show(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .profile?: try {
      guard case .profile(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .audiobook?: try {
      guard case .audiobook(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .autocompleteQuery?: try {
      guard case .autocompleteQuery(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2046)
    }()
    case nil: break
    }
    try { if let v = self._serpMetadata {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2047)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPSearchResultEntity, rhs: SPSearchResultEntity) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.imageUri != rhs.imageUri {return false}
    if lhs.info != rhs.info {return false}
    if lhs._serpMetadata != rhs._serpMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
