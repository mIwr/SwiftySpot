// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Login5.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Login request
struct SPLoginRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: SPShortClientInfo {
    get {return _client ?? SPShortClientInfo()}
    set {_client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  var hasClient: Bool {return self._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  mutating func clearClient() {self._client = nil}

  var context: Data {
    get {return _context ?? Data()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var answerData: SPLoginChallengeAnswerData {
    get {return _answerData ?? SPLoginChallengeAnswerData()}
    set {_answerData = newValue}
  }
  /// Returns true if `answerData` has been explicitly set.
  var hasAnswerData: Bool {return self._answerData != nil}
  /// Clears the value of `answerData`. Subsequent reads from it will return its default value.
  mutating func clearAnswerData() {self._answerData = nil}

  var interaction: SPLoginInteraction {
    get {return _interaction ?? SPLoginInteraction()}
    set {_interaction = newValue}
  }
  /// Returns true if `interaction` has been explicitly set.
  var hasInteraction: Bool {return self._interaction != nil}
  /// Clears the value of `interaction`. Subsequent reads from it will return its default value.
  mutating func clearInteraction() {self._interaction = nil}

  var request: SPLoginRequest.OneOf_Request? = nil

  ///Stored credentials from previous authorization
  var stored: SPStoredCredential {
    get {
      if case .stored(let v)? = request {return v}
      return SPStoredCredential()
    }
    set {request = .stored(newValue)}
  }

  ///Login v3 credentials
  var passwordV3: SPPassword {
    get {
      if case .passwordV3(let v)? = request {return v}
      return SPPassword()
    }
    set {request = .passwordV3(newValue)}
  }

  var facebook: SPFacebookAccessToken {
    get {
      if case .facebook(let v)? = request {return v}
      return SPFacebookAccessToken()
    }
    set {request = .facebook(newValue)}
  }

  var phone: SPPhoneNumber {
    get {
      if case .phone(let v)? = request {return v}
      return SPPhoneNumber()
    }
    set {request = .phone(newValue)}
  }

  ///Magic link from e-mail
  var oneTimeToken: SPOneTimeToken {
    get {
      if case .oneTimeToken(let v)? = request {return v}
      return SPOneTimeToken()
    }
    set {request = .oneTimeToken(newValue)}
  }

  var parentChildCred: SPParentChildCredential {
    get {
      if case .parentChildCred(let v)? = request {return v}
      return SPParentChildCredential()
    }
    set {request = .parentChildCred(newValue)}
  }

  var appleSignIn: SPAppleSignInCredential {
    get {
      if case .appleSignIn(let v)? = request {return v}
      return SPAppleSignInCredential()
    }
    set {request = .appleSignIn(newValue)}
  }

  ///Login v4 credentials
  var passwordV4: SPPassword {
    get {
      if case .passwordV4(let v)? = request {return v}
      return SPPassword()
    }
    set {request = .passwordV4(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    ///Stored credentials from previous authorization
    case stored(SPStoredCredential)
    ///Login v3 credentials
    case passwordV3(SPPassword)
    case facebook(SPFacebookAccessToken)
    case phone(SPPhoneNumber)
    ///Magic link from e-mail
    case oneTimeToken(SPOneTimeToken)
    case parentChildCred(SPParentChildCredential)
    case appleSignIn(SPAppleSignInCredential)
    ///Login v4 credentials
    case passwordV4(SPPassword)

  }

  init() {}

  fileprivate var _client: SPShortClientInfo? = nil
  fileprivate var _context: Data? = nil
  fileprivate var _answerData: SPLoginChallengeAnswerData? = nil
  fileprivate var _interaction: SPLoginInteraction? = nil
}

struct SPLoginInteraction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown: Data = Data()

  var finish: SPLoginInteractionFinish {
    get {return _finish ?? SPLoginInteractionFinish()}
    set {_finish = newValue}
  }
  /// Returns true if `finish` has been explicitly set.
  var hasFinish: Bool {return self._finish != nil}
  /// Clears the value of `finish`. Subsequent reads from it will return its default value.
  mutating func clearFinish() {self._finish = nil}

  var hint: SPLoginInteractionHint {
    get {return _hint ?? SPLoginInteractionHint()}
    set {_hint = newValue}
  }
  /// Returns true if `hint` has been explicitly set.
  var hasHint: Bool {return self._hint != nil}
  /// Clears the value of `hint`. Subsequent reads from it will return its default value.
  mutating func clearHint() {self._hint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _finish: SPLoginInteractionFinish? = nil
  fileprivate var _hint: SPLoginInteractionHint? = nil
}

struct SPLoginInteractionFinish: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown1: Int32 = 0

  var uri: String = String()

  var nonce: String = String()

  var unknown2: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPLoginInteractionHint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uiLocale: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPPhoneNumber: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: String = String()

  var isoCountryCode: String = String()

  var countryCallingCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPLoginChallengeAnswerData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answers: [SPLoginChallengeAnswer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPLoginChallengeAnswer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answer: SPLoginChallengeAnswer.OneOf_Answer? = nil

  var hashcash: SPHashcashChallengeAnswer {
    get {
      if case .hashcash(let v)? = answer {return v}
      return SPHashcashChallengeAnswer()
    }
    set {answer = .hashcash(newValue)}
  }

  var code: SPCodeChallengeAnswer {
    get {
      if case .code(let v)? = answer {return v}
      return SPCodeChallengeAnswer()
    }
    set {answer = .code(newValue)}
  }

  var captcha: SPCaptchaChallengeAnswer {
    get {
      if case .captcha(let v)? = answer {return v}
      return SPCaptchaChallengeAnswer()
    }
    set {answer = .captcha(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Answer: Equatable, Sendable {
    case hashcash(SPHashcashChallengeAnswer)
    case code(SPCodeChallengeAnswer)
    case captcha(SPCaptchaChallengeAnswer)

  }

  init() {}
}

///Login response
struct SPLoginResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var auth: SPAuthToken {
    get {
      if case .auth(let v)? = _storage._response {return v}
      return SPAuthToken()
    }
    set {_uniqueStorage()._response = .auth(newValue)}
  }

  var error: SPLoginResponse.Error {
    get {
      if case .error(let v)? = _storage._response {return v}
      return .unknownError
    }
    set {_uniqueStorage()._response = .error(newValue)}
  }

  var challenges: SPLoginChallengesData {
    get {
      if case .challenges(let v)? = _storage._response {return v}
      return SPLoginChallengesData()
    }
    set {_uniqueStorage()._response = .challenges(newValue)}
  }

  var warnings: [SPLoginResponse.Warning] {
    get {return _storage._warnings}
    set {_uniqueStorage()._warnings = newValue}
  }

  var context: Data {
    get {return _storage._context ?? Data()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {_uniqueStorage()._context = nil}

  var idToken: String {
    get {return _storage._idToken ?? String()}
    set {_uniqueStorage()._idToken = newValue}
  }
  /// Returns true if `idToken` has been explicitly set.
  var hasIDToken: Bool {return _storage._idToken != nil}
  /// Clears the value of `idToken`. Subsequent reads from it will return its default value.
  mutating func clearIDToken() {_uniqueStorage()._idToken = nil}

  var userInfo: SPUserInfo {
    get {return _storage._userInfo ?? SPUserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  var uuidUnknown: String {
    get {return _storage._uuidUnknown ?? String()}
    set {_uniqueStorage()._uuidUnknown = newValue}
  }
  /// Returns true if `uuidUnknown` has been explicitly set.
  var hasUuidUnknown: Bool {return _storage._uuidUnknown != nil}
  /// Clears the value of `uuidUnknown`. Subsequent reads from it will return its default value.
  mutating func clearUuidUnknown() {_uniqueStorage()._uuidUnknown = nil}

  var uuidUnknown2: String {
    get {return _storage._uuidUnknown2 ?? String()}
    set {_uniqueStorage()._uuidUnknown2 = newValue}
  }
  /// Returns true if `uuidUnknown2` has been explicitly set.
  var hasUuidUnknown2: Bool {return _storage._uuidUnknown2 != nil}
  /// Clears the value of `uuidUnknown2`. Subsequent reads from it will return its default value.
  mutating func clearUuidUnknown2() {_uniqueStorage()._uuidUnknown2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case auth(SPAuthToken)
    case error(SPLoginResponse.Error)
    case challenges(SPLoginChallengesData)

  }

  enum Warning: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknownWarning // = 0
    case deprecatedProtocolVersion // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownWarning
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownWarning
      case 1: self = .deprecatedProtocolVersion
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownWarning: return 0
      case .deprecatedProtocolVersion: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SPLoginResponse.Warning] = [
      .unknownWarning,
      .deprecatedProtocolVersion,
    ]

  }

  enum Error: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknownError // = 0
    case invalidCredentials // = 1
    case badRequest // = 2
    case unsupportedLoginProtocol // = 3
    case timeout // = 4
    case unknownIdentifier // = 5
    case tooManyAttempts // = 6
    case invalidPhonenumber // = 7
    case tryAgainLater // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      case 1: self = .invalidCredentials
      case 2: self = .badRequest
      case 3: self = .unsupportedLoginProtocol
      case 4: self = .timeout
      case 5: self = .unknownIdentifier
      case 6: self = .tooManyAttempts
      case 7: self = .invalidPhonenumber
      case 8: self = .tryAgainLater
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .invalidCredentials: return 1
      case .badRequest: return 2
      case .unsupportedLoginProtocol: return 3
      case .timeout: return 4
      case .unknownIdentifier: return 5
      case .tooManyAttempts: return 6
      case .invalidPhonenumber: return 7
      case .tryAgainLater: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SPLoginResponse.Error] = [
      .unknownError,
      .invalidCredentials,
      .badRequest,
      .unsupportedLoginProtocol,
      .timeout,
      .unknownIdentifier,
      .tooManyAttempts,
      .invalidPhonenumber,
      .tryAgainLater,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SPAuthToken: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var token: String = String()

  var storedCredential: Data = Data()

  var expiresInS: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPUserInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var email: String = String()

  var emailVerified: Bool = false

  var birthdate: String = String()

  var gender: SPUserInfo.Gender = .unknown

  var phone: String = String()

  var phoneVerified: Bool = false

  var emailAlredyRegistered: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Gender: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case male // = 1
    case female // = 2
    case neutral // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .male
      case 2: self = .female
      case 3: self = .neutral
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .male: return 1
      case .female: return 2
      case .neutral: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SPUserInfo.Gender] = [
      .unknown,
      .male,
      .female,
      .neutral,
    ]

  }

  init() {}
}

struct SPLoginChallengesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var challenges: [SPLoginChallenge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPLoginChallenge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var method: SPLoginChallenge.OneOf_Method? = nil

  var hashcash: SPHashcashChallenge {
    get {
      if case .hashcash(let v)? = method {return v}
      return SPHashcashChallenge()
    }
    set {method = .hashcash(newValue)}
  }

  var code: SPCodeChallenge {
    get {
      if case .code(let v)? = method {return v}
      return SPCodeChallenge()
    }
    set {method = .code(newValue)}
  }

  var captcha: SPCaptchaChallenge {
    get {
      if case .captcha(let v)? = method {return v}
      return SPCaptchaChallenge()
    }
    set {method = .captcha(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Method: Equatable, Sendable {
    case hashcash(SPHashcashChallenge)
    case code(SPCodeChallenge)
    case captcha(SPCaptchaChallenge)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SPLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "context"),
    3: .standard(proto: "answer_data"),
    4: .same(proto: "interaction"),
    100: .same(proto: "stored"),
    101: .standard(proto: "password_v3"),
    102: .same(proto: "facebook"),
    103: .same(proto: "phone"),
    104: .standard(proto: "one_time_token"),
    105: .standard(proto: "parent_child_cred"),
    106: .standard(proto: "apple_sign_in"),
    109: .standard(proto: "password_v4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._client) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._answerData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._interaction) }()
      case 100: try {
        var v: SPStoredCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .stored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .stored(v)
        }
      }()
      case 101: try {
        var v: SPPassword?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .passwordV3(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .passwordV3(v)
        }
      }()
      case 102: try {
        var v: SPFacebookAccessToken?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .facebook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .facebook(v)
        }
      }()
      case 103: try {
        var v: SPPhoneNumber?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .phone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .phone(v)
        }
      }()
      case 104: try {
        var v: SPOneTimeToken?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .oneTimeToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .oneTimeToken(v)
        }
      }()
      case 105: try {
        var v: SPParentChildCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .parentChildCred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .parentChildCred(v)
        }
      }()
      case 106: try {
        var v: SPAppleSignInCredential?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .appleSignIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .appleSignIn(v)
        }
      }()
      case 109: try {
        var v: SPPassword?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .passwordV4(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .passwordV4(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._client {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._answerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._interaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.request {
    case .stored?: try {
      guard case .stored(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .passwordV3?: try {
      guard case .passwordV3(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .facebook?: try {
      guard case .facebook(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .phone?: try {
      guard case .phone(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .oneTimeToken?: try {
      guard case .oneTimeToken(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .parentChildCred?: try {
      guard case .parentChildCred(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .appleSignIn?: try {
      guard case .appleSignIn(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .passwordV4?: try {
      guard case .passwordV4(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginRequest, rhs: SPLoginRequest) -> Bool {
    if lhs._client != rhs._client {return false}
    if lhs._context != rhs._context {return false}
    if lhs._answerData != rhs._answerData {return false}
    if lhs._interaction != rhs._interaction {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginInteraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginInteraction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "finish"),
    3: .same(proto: "hint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unknown) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._finish) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unknown.isEmpty {
      try visitor.visitSingularBytesField(value: self.unknown, fieldNumber: 1)
    }
    try { if let v = self._finish {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginInteraction, rhs: SPLoginInteraction) -> Bool {
    if lhs.unknown != rhs.unknown {return false}
    if lhs._finish != rhs._finish {return false}
    if lhs._hint != rhs._hint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginInteractionFinish: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginInteractionFinish"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown1"),
    2: .same(proto: "uri"),
    3: .same(proto: "nonce"),
    4: .same(proto: "unknown2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.unknown1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nonce) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.unknown2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unknown1 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknown1, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 3)
    }
    if self.unknown2 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknown2, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginInteractionFinish, rhs: SPLoginInteractionFinish) -> Bool {
    if lhs.unknown1 != rhs.unknown1 {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknown2 != rhs.unknown2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginInteractionHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginInteractionHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ui_locale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uiLocale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uiLocale.isEmpty {
      try visitor.visitSingularStringField(value: self.uiLocale, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginInteractionHint, rhs: SPLoginInteractionHint) -> Bool {
    if lhs.uiLocale != rhs.uiLocale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPPhoneNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PhoneNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .standard(proto: "iso_country_code"),
    3: .standard(proto: "country_calling_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.isoCountryCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.countryCallingCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 1)
    }
    if !self.isoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.isoCountryCode, fieldNumber: 2)
    }
    if !self.countryCallingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCallingCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPPhoneNumber, rhs: SPPhoneNumber) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs.isoCountryCode != rhs.isoCountryCode {return false}
    if lhs.countryCallingCode != rhs.countryCallingCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginChallengeAnswerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengeAnswerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginChallengeAnswerData, rhs: SPLoginChallengeAnswerData) -> Bool {
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginChallengeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashcash"),
    2: .same(proto: "code"),
    3: .same(proto: "captcha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SPHashcashChallengeAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .hashcash(v)
        }
      }()
      case 2: try {
        var v: SPCodeChallengeAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .code(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .code(v)
        }
      }()
      case 3: try {
        var v: SPCaptchaChallengeAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .captcha(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .captcha(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.answer {
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .code?: try {
      guard case .code(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .captcha?: try {
      guard case .captcha(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginChallengeAnswer, rhs: SPLoginChallengeAnswer) -> Bool {
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "error"),
    3: .same(proto: "challenges"),
    4: .same(proto: "warnings"),
    5: .same(proto: "context"),
    6: .standard(proto: "id_token"),
    7: .standard(proto: "user_info"),
    8: .standard(proto: "uuid_unknown"),
    9: .standard(proto: "uuid_unknown2"),
  ]

  fileprivate class _StorageClass {
    var _response: SPLoginResponse.OneOf_Response?
    var _warnings: [SPLoginResponse.Warning] = []
    var _context: Data? = nil
    var _idToken: String? = nil
    var _userInfo: SPUserInfo? = nil
    var _uuidUnknown: String? = nil
    var _uuidUnknown2: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
      _warnings = source._warnings
      _context = source._context
      _idToken = source._idToken
      _userInfo = source._userInfo
      _uuidUnknown = source._uuidUnknown
      _uuidUnknown2 = source._uuidUnknown2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: SPAuthToken?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .auth(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .auth(v)
          }
        }()
        case 2: try {
          var v: SPLoginResponse.Error?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._response != nil {try decoder.handleConflictingOneOf()}
            _storage._response = .error(v)
          }
        }()
        case 3: try {
          var v: SPLoginChallengesData?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .challenges(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .challenges(v)
          }
        }()
        case 4: try { try decoder.decodeRepeatedEnumField(value: &_storage._warnings) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._context) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._idToken) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._uuidUnknown) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._uuidUnknown2) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._response {
      case .auth?: try {
        guard case .auth(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .error?: try {
        guard case .error(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }()
      case .challenges?: try {
        guard case .challenges(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if !_storage._warnings.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._warnings, fieldNumber: 4)
      }
      try { if let v = _storage._context {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._idToken {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._uuidUnknown {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._uuidUnknown2 {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginResponse, rhs: SPLoginResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._response != rhs_storage._response {return false}
        if _storage._warnings != rhs_storage._warnings {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._idToken != rhs_storage._idToken {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._uuidUnknown != rhs_storage._uuidUnknown {return false}
        if _storage._uuidUnknown2 != rhs_storage._uuidUnknown2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginResponse.Warning: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WARNING"),
    1: .same(proto: "DEPRECATED_PROTOCOL_VERSION"),
  ]
}

extension SPLoginResponse.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "INVALID_CREDENTIALS"),
    2: .same(proto: "BAD_REQUEST"),
    3: .same(proto: "UNSUPPORTED_LOGIN_PROTOCOL"),
    4: .same(proto: "TIMEOUT"),
    5: .same(proto: "UNKNOWN_IDENTIFIER"),
    6: .same(proto: "TOO_MANY_ATTEMPTS"),
    7: .same(proto: "INVALID_PHONENUMBER"),
    8: .same(proto: "TRY_AGAIN_LATER"),
  ]
}

extension SPAuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "token"),
    3: .standard(proto: "stored_credential"),
    4: .standard(proto: "expires_in_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.storedCredential) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.storedCredential.isEmpty {
      try visitor.visitSingularBytesField(value: self.storedCredential, fieldNumber: 3)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPAuthToken, rhs: SPAuthToken) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.token != rhs.token {return false}
    if lhs.storedCredential != rhs.storedCredential {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPUserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "email"),
    3: .standard(proto: "email_verified"),
    4: .same(proto: "birthdate"),
    5: .same(proto: "gender"),
    6: .same(proto: "phone"),
    7: .standard(proto: "phone_verified"),
    8: .standard(proto: "email_alredy_registered"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.emailVerified) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.birthdate) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.phoneVerified) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.emailAlredyRegistered) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.emailVerified != false {
      try visitor.visitSingularBoolField(value: self.emailVerified, fieldNumber: 3)
    }
    if !self.birthdate.isEmpty {
      try visitor.visitSingularStringField(value: self.birthdate, fieldNumber: 4)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 5)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 6)
    }
    if self.phoneVerified != false {
      try visitor.visitSingularBoolField(value: self.phoneVerified, fieldNumber: 7)
    }
    if self.emailAlredyRegistered != false {
      try visitor.visitSingularBoolField(value: self.emailAlredyRegistered, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPUserInfo, rhs: SPUserInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.email != rhs.email {return false}
    if lhs.emailVerified != rhs.emailVerified {return false}
    if lhs.birthdate != rhs.birthdate {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.phoneVerified != rhs.phoneVerified {return false}
    if lhs.emailAlredyRegistered != rhs.emailAlredyRegistered {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPUserInfo.Gender: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "MALE"),
    2: .same(proto: "FEMALE"),
    3: .same(proto: "NEUTRAL"),
  ]
}

extension SPLoginChallengesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallengesData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.challenges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.challenges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginChallengesData, rhs: SPLoginChallengesData) -> Bool {
    if lhs.challenges != rhs.challenges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPLoginChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashcash"),
    2: .same(proto: "code"),
    3: .same(proto: "captcha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SPHashcashChallenge?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .hashcash(v)
        }
      }()
      case 2: try {
        var v: SPCodeChallenge?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .code(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .code(v)
        }
      }()
      case 3: try {
        var v: SPCaptchaChallenge?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .captcha(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .captcha(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.method {
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .code?: try {
      guard case .code(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .captcha?: try {
      guard case .captcha(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPLoginChallenge, rhs: SPLoginChallenge) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
