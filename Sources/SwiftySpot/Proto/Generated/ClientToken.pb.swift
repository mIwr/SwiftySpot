// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ClientToken.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SPClientTokenRequestType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case requestUnknown // = 0
  case requestClientDataRequest // = 1
  case requestChallengeAnswersRequest // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .requestUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requestUnknown
    case 1: self = .requestClientDataRequest
    case 2: self = .requestChallengeAnswersRequest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .requestUnknown: return 0
    case .requestClientDataRequest: return 1
    case .requestChallengeAnswersRequest: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SPClientTokenRequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPClientTokenRequestType] = [
    .requestUnknown,
    .requestClientDataRequest,
    .requestChallengeAnswersRequest,
  ]
}

#endif  // swift(>=4.2)

enum SPChallengeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case challengeUnknown // = 0
  case challengeClientSecretHmac // = 1
  case challengeEvaluateJs // = 2
  case challengeHashCash // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .challengeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .challengeUnknown
    case 1: self = .challengeClientSecretHmac
    case 2: self = .challengeEvaluateJs
    case 3: self = .challengeHashCash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .challengeUnknown: return 0
    case .challengeClientSecretHmac: return 1
    case .challengeEvaluateJs: return 2
    case .challengeHashCash: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SPChallengeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPChallengeType] = [
    .challengeUnknown,
    .challengeClientSecretHmac,
    .challengeEvaluateJs,
    .challengeHashCash,
  ]
}

#endif  // swift(>=4.2)

enum SPClientTokenResponseType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case responseUnknown // = 0
  case responseGrantedTokenResponse // = 1
  case responseChallengesResponse // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .responseUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .responseUnknown
    case 1: self = .responseGrantedTokenResponse
    case 2: self = .responseChallengesResponse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .responseUnknown: return 0
    case .responseGrantedTokenResponse: return 1
    case .responseChallengesResponse: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SPClientTokenResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPClientTokenResponseType] = [
    .responseUnknown,
    .responseGrantedTokenResponse,
    .responseChallengesResponse,
  ]
}

#endif  // swift(>=4.2)

struct SPClientTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenRequestType = .requestUnknown

  var request: SPClientTokenRequest.OneOf_Request? = nil

  var client: SPClientInfo {
    get {
      if case .client(let v)? = request {return v}
      return SPClientInfo()
    }
    set {request = .client(newValue)}
  }

  var answerData: SPChallengeAnswerData {
    get {
      if case .answerData(let v)? = request {return v}
      return SPChallengeAnswerData()
    }
    set {request = .answerData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case client(SPClientInfo)
    case answerData(SPChallengeAnswerData)

  #if !swift(>=4.1)
    static func ==(lhs: SPClientTokenRequest.OneOf_Request, rhs: SPClientTokenRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.client, .client): return {
        guard case .client(let l) = lhs, case .client(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.answerData, .answerData): return {
        guard case .answerData(let l) = lhs, case .answerData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SPChallengeAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPChallengeType = .challengeUnknown

  var answer: SPChallengeAnswer.OneOf_Answer? = nil

  var clSecretAnswer: SPClientSecretHMACAnswer {
    get {
      if case .clSecretAnswer(let v)? = answer {return v}
      return SPClientSecretHMACAnswer()
    }
    set {answer = .clSecretAnswer(newValue)}
  }

  var evaluateJs: SPEvaluateJSAnswer {
    get {
      if case .evaluateJs(let v)? = answer {return v}
      return SPEvaluateJSAnswer()
    }
    set {answer = .evaluateJs(newValue)}
  }

  var hashcash: SPHashCashAnswer {
    get {
      if case .hashcash(let v)? = answer {return v}
      return SPHashCashAnswer()
    }
    set {answer = .hashcash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Answer: Equatable {
    case clSecretAnswer(SPClientSecretHMACAnswer)
    case evaluateJs(SPEvaluateJSAnswer)
    case hashcash(SPHashCashAnswer)

  #if !swift(>=4.1)
    static func ==(lhs: SPChallengeAnswer.OneOf_Answer, rhs: SPChallengeAnswer.OneOf_Answer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.clSecretAnswer, .clSecretAnswer): return {
        guard case .clSecretAnswer(let l) = lhs, case .clSecretAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evaluateJs, .evaluateJs): return {
        guard case .evaluateJs(let l) = lhs, case .evaluateJs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcash, .hashcash): return {
        guard case .hashcash(let l) = lhs, case .hashcash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SPClientSecretHMACAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hmac: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPEvaluateJSAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPHashCashAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suffix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPChallengeAnswerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///librespot-java: string state = 1;
  var context: String = String()

  var answers: [SPChallengeAnswer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenResponseType = .responseUnknown

  var response: SPClientTokenResponse.OneOf_Response? = nil

  var token: SPClientToken {
    get {
      if case .token(let v)? = response {return v}
      return SPClientToken()
    }
    set {response = .token(newValue)}
  }

  var challenges: SPChallengesData {
    get {
      if case .challenges(let v)? = response {return v}
      return SPChallengesData()
    }
    set {response = .challenges(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case token(SPClientToken)
    case challenges(SPChallengesData)

  #if !swift(>=4.1)
    static func ==(lhs: SPClientTokenResponse.OneOf_Response, rhs: SPClientTokenResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.token, .token): return {
        guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challenges, .challenges): return {
        guard case .challenges(let l) = lhs, case .challenges(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SPClientToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val: String = String()

  var expiresInS: Int32 = 0

  var refreshAfterS: Int32 = 0

  var domains: [SPTokenDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPTokenDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPChallengesData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var context: String = String()

  var challenges: [SPChallenge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPChallengeType = .challengeUnknown

  var parameters: SPChallenge.OneOf_Parameters? = nil

  var clSecretParameters: SPClientSecretParameters {
    get {
      if case .clSecretParameters(let v)? = parameters {return v}
      return SPClientSecretParameters()
    }
    set {parameters = .clSecretParameters(newValue)}
  }

  var jsParameters: SPEvaluateJSParameters {
    get {
      if case .jsParameters(let v)? = parameters {return v}
      return SPEvaluateJSParameters()
    }
    set {parameters = .jsParameters(newValue)}
  }

  var hashcashParameters: SPHashCashParameters {
    get {
      if case .hashcashParameters(let v)? = parameters {return v}
      return SPHashCashParameters()
    }
    set {parameters = .hashcashParameters(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Parameters: Equatable {
    case clSecretParameters(SPClientSecretParameters)
    case jsParameters(SPEvaluateJSParameters)
    case hashcashParameters(SPHashCashParameters)

  #if !swift(>=4.1)
    static func ==(lhs: SPChallenge.OneOf_Parameters, rhs: SPChallenge.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.clSecretParameters, .clSecretParameters): return {
        guard case .clSecretParameters(let l) = lhs, case .clSecretParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jsParameters, .jsParameters): return {
        guard case .jsParameters(let l) = lhs, case .jsParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashParameters, .hashcashParameters): return {
        guard case .hashcashParameters(let l) = lhs, case .hashcashParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SPClientSecretParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var salt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPEvaluateJSParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var libraries: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPHashCashParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var length: Int32 = 0

  var prefix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenBadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SPClientTokenRequestType: @unchecked Sendable {}
extension SPChallengeType: @unchecked Sendable {}
extension SPClientTokenResponseType: @unchecked Sendable {}
extension SPClientTokenRequest: @unchecked Sendable {}
extension SPClientTokenRequest.OneOf_Request: @unchecked Sendable {}
extension SPChallengeAnswer: @unchecked Sendable {}
extension SPChallengeAnswer.OneOf_Answer: @unchecked Sendable {}
extension SPClientSecretHMACAnswer: @unchecked Sendable {}
extension SPEvaluateJSAnswer: @unchecked Sendable {}
extension SPHashCashAnswer: @unchecked Sendable {}
extension SPChallengeAnswerData: @unchecked Sendable {}
extension SPClientTokenResponse: @unchecked Sendable {}
extension SPClientTokenResponse.OneOf_Response: @unchecked Sendable {}
extension SPClientToken: @unchecked Sendable {}
extension SPTokenDomain: @unchecked Sendable {}
extension SPChallengesData: @unchecked Sendable {}
extension SPChallenge: @unchecked Sendable {}
extension SPChallenge.OneOf_Parameters: @unchecked Sendable {}
extension SPClientSecretParameters: @unchecked Sendable {}
extension SPEvaluateJSParameters: @unchecked Sendable {}
extension SPHashCashParameters: @unchecked Sendable {}
extension SPClientTokenBadRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SPClientTokenRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_UNKNOWN"),
    1: .same(proto: "REQUEST_CLIENT_DATA_REQUEST"),
    2: .same(proto: "REQUEST_CHALLENGE_ANSWERS_REQUEST"),
  ]
}

extension SPChallengeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHALLENGE_UNKNOWN"),
    1: .same(proto: "CHALLENGE_CLIENT_SECRET_HMAC"),
    2: .same(proto: "CHALLENGE_EVALUATE_JS"),
    3: .same(proto: "CHALLENGE_HASH_CASH"),
  ]
}

extension SPClientTokenResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESPONSE_UNKNOWN"),
    1: .same(proto: "RESPONSE_GRANTED_TOKEN_RESPONSE"),
    2: .same(proto: "RESPONSE_CHALLENGES_RESPONSE"),
  ]
}

extension SPClientTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "client"),
    3: .same(proto: "answerData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientInfo?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .client(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .client(v)
        }
      }()
      case 3: try {
        var v: SPChallengeAnswerData?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .answerData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .answerData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .requestUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.request {
    case .client?: try {
      guard case .client(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .answerData?: try {
      guard case .answerData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenRequest, rhs: SPClientTokenRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPChallengeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretAnswer"),
    3: .same(proto: "evaluateJS"),
    4: .same(proto: "hashcash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientSecretHMACAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .clSecretAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .clSecretAnswer(v)
        }
      }()
      case 3: try {
        var v: SPEvaluateJSAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .evaluateJs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .evaluateJs(v)
        }
      }()
      case 4: try {
        var v: SPHashCashAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .hashcash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.answer {
    case .clSecretAnswer?: try {
      guard case .clSecretAnswer(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .evaluateJs?: try {
      guard case .evaluateJs(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPChallengeAnswer, rhs: SPChallengeAnswer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientSecretHMACAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientSecretHMACAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hmac"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hmac) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hmac.isEmpty {
      try visitor.visitSingularStringField(value: self.hmac, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientSecretHMACAnswer, rhs: SPClientSecretHMACAnswer) -> Bool {
    if lhs.hmac != rhs.hmac {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPEvaluateJSAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EvaluateJSAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPEvaluateJSAnswer, rhs: SPEvaluateJSAnswer) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPHashCashAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashCashAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suffix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPHashCashAnswer, rhs: SPHashCashAnswer) -> Bool {
    if lhs.suffix != rhs.suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPChallengeAnswerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeAnswerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPChallengeAnswerData, rhs: SPChallengeAnswerData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
    3: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientToken?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .token(v)
        }
      }()
      case 3: try {
        var v: SPChallengesData?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .challenges(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .challenges(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .responseUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.response {
    case .token?: try {
      guard case .token(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .challenges?: try {
      guard case .challenges(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenResponse, rhs: SPClientTokenResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
    2: .same(proto: "expiresInS"),
    3: .same(proto: "refreshAfterS"),
    4: .same(proto: "domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.val) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.refreshAfterS) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.domains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 1)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 2)
    }
    if self.refreshAfterS != 0 {
      try visitor.visitSingularInt32Field(value: self.refreshAfterS, fieldNumber: 3)
    }
    if !self.domains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.domains, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientToken, rhs: SPClientToken) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.refreshAfterS != rhs.refreshAfterS {return false}
    if lhs.domains != rhs.domains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPTokenDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TokenDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPTokenDomain, rhs: SPTokenDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPChallengesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengesData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.challenges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.challenges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.challenges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPChallengesData, rhs: SPChallengesData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.challenges != rhs.challenges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Challenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretParameters"),
    3: .same(proto: "jsParameters"),
    4: .same(proto: "hashcashParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientSecretParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .clSecretParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .clSecretParameters(v)
        }
      }()
      case 3: try {
        var v: SPEvaluateJSParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .jsParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .jsParameters(v)
        }
      }()
      case 4: try {
        var v: SPHashCashParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .hashcashParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .hashcashParameters(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.parameters {
    case .clSecretParameters?: try {
      guard case .clSecretParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .jsParameters?: try {
      guard case .jsParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcashParameters?: try {
      guard case .hashcashParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPChallenge, rhs: SPChallenge) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientSecretParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientSecretParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientSecretParameters, rhs: SPClientSecretParameters) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPEvaluateJSParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EvaluateJSParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "libraries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.libraries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.libraries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.libraries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPEvaluateJSParameters, rhs: SPEvaluateJSParameters) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.libraries != rhs.libraries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPHashCashParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashCashParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
    2: .same(proto: "prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPHashCashParameters, rhs: SPHashCashParameters) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenBadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenBadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errMsg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenBadRequest, rhs: SPClientTokenBadRequest) -> Bool {
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
