// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ClientToken.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SPClientTokenRequestType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case requestUnknown // = 0
  case requestClientDataRequest // = 1
  case requestChallengeAnswersRequest // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .requestUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requestUnknown
    case 1: self = .requestClientDataRequest
    case 2: self = .requestChallengeAnswersRequest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .requestUnknown: return 0
    case .requestClientDataRequest: return 1
    case .requestChallengeAnswersRequest: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPClientTokenRequestType] = [
    .requestUnknown,
    .requestClientDataRequest,
    .requestChallengeAnswersRequest,
  ]

}

enum SPClientTokenChallengeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case challengeUnknown // = 0
  case challengeClientSecretHmac // = 1
  case challengeEvaluateJs // = 2
  case challengeHashCash // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .challengeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .challengeUnknown
    case 1: self = .challengeClientSecretHmac
    case 2: self = .challengeEvaluateJs
    case 3: self = .challengeHashCash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .challengeUnknown: return 0
    case .challengeClientSecretHmac: return 1
    case .challengeEvaluateJs: return 2
    case .challengeHashCash: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPClientTokenChallengeType] = [
    .challengeUnknown,
    .challengeClientSecretHmac,
    .challengeEvaluateJs,
    .challengeHashCash,
  ]

}

enum SPClientTokenResponseType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case responseUnknown // = 0
  case responseGrantedTokenResponse // = 1
  case responseChallengesResponse // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .responseUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .responseUnknown
    case 1: self = .responseGrantedTokenResponse
    case 2: self = .responseChallengesResponse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .responseUnknown: return 0
    case .responseGrantedTokenResponse: return 1
    case .responseChallengesResponse: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SPClientTokenResponseType] = [
    .responseUnknown,
    .responseGrantedTokenResponse,
    .responseChallengesResponse,
  ]

}

struct SPClientToken: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val: String = String()

  var expiresInS: Int32 = 0

  var refreshAfterS: Int32 = 0

  var domains: [SPClientTokenDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenDomain: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenRequestType = .requestUnknown

  var request: SPClientTokenRequest.OneOf_Request? = nil

  var client: SPClientInfo {
    get {
      if case .client(let v)? = request {return v}
      return SPClientInfo()
    }
    set {request = .client(newValue)}
  }

  var answerData: SPClientTokenChallengeAnswerData {
    get {
      if case .answerData(let v)? = request {return v}
      return SPClientTokenChallengeAnswerData()
    }
    set {request = .answerData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case client(SPClientInfo)
    case answerData(SPClientTokenChallengeAnswerData)

  }

  init() {}
}

struct SPClientTokenChallengeAnswerData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///librespot-java: string state = 1;
  var context: String = String()

  var answers: [SPClientTokenChallengeAnswer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenChallengeAnswer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenChallengeType = .challengeUnknown

  var answer: SPClientTokenChallengeAnswer.OneOf_Answer? = nil

  var clSecretAnswer: SPClientSecretHMACAnswer {
    get {
      if case .clSecretAnswer(let v)? = answer {return v}
      return SPClientSecretHMACAnswer()
    }
    set {answer = .clSecretAnswer(newValue)}
  }

  var evaluateJs: SPEvaluateJSAnswer {
    get {
      if case .evaluateJs(let v)? = answer {return v}
      return SPEvaluateJSAnswer()
    }
    set {answer = .evaluateJs(newValue)}
  }

  var hashcash: SPHashcashChallengeAnswer {
    get {
      if case .hashcash(let v)? = answer {return v}
      return SPHashcashChallengeAnswer()
    }
    set {answer = .hashcash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Answer: Equatable, Sendable {
    case clSecretAnswer(SPClientSecretHMACAnswer)
    case evaluateJs(SPEvaluateJSAnswer)
    case hashcash(SPHashcashChallengeAnswer)

  }

  init() {}
}

struct SPClientTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenResponseType = .responseUnknown

  var response: SPClientTokenResponse.OneOf_Response? = nil

  var token: SPClientToken {
    get {
      if case .token(let v)? = response {return v}
      return SPClientToken()
    }
    set {response = .token(newValue)}
  }

  var challenges: SPClientTokenChallengesData {
    get {
      if case .challenges(let v)? = response {return v}
      return SPClientTokenChallengesData()
    }
    set {response = .challenges(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case token(SPClientToken)
    case challenges(SPClientTokenChallengesData)

  }

  init() {}
}

struct SPClientTokenChallengesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var context: String = String()

  var challenges: [SPClientTokenChallenge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenChallenge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SPClientTokenChallengeType = .challengeUnknown

  var parameters: SPClientTokenChallenge.OneOf_Parameters? = nil

  var clSecretParameters: SPClientSecretChallenge {
    get {
      if case .clSecretParameters(let v)? = parameters {return v}
      return SPClientSecretChallenge()
    }
    set {parameters = .clSecretParameters(newValue)}
  }

  var jsParameters: SPEvaluateJSChallenge {
    get {
      if case .jsParameters(let v)? = parameters {return v}
      return SPEvaluateJSChallenge()
    }
    set {parameters = .jsParameters(newValue)}
  }

  var hashcashParameters: SPHashcashChallenge {
    get {
      if case .hashcashParameters(let v)? = parameters {return v}
      return SPHashcashChallenge()
    }
    set {parameters = .hashcashParameters(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Parameters: Equatable, Sendable {
    case clSecretParameters(SPClientSecretChallenge)
    case jsParameters(SPEvaluateJSChallenge)
    case hashcashParameters(SPHashcashChallenge)

  }

  init() {}
}

struct SPClientTokenBadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SPClientTokenRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_UNKNOWN"),
    1: .same(proto: "REQUEST_CLIENT_DATA_REQUEST"),
    2: .same(proto: "REQUEST_CHALLENGE_ANSWERS_REQUEST"),
  ]
}

extension SPClientTokenChallengeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHALLENGE_UNKNOWN"),
    1: .same(proto: "CHALLENGE_CLIENT_SECRET_HMAC"),
    2: .same(proto: "CHALLENGE_EVALUATE_JS"),
    3: .same(proto: "CHALLENGE_HASH_CASH"),
  ]
}

extension SPClientTokenResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESPONSE_UNKNOWN"),
    1: .same(proto: "RESPONSE_GRANTED_TOKEN_RESPONSE"),
    2: .same(proto: "RESPONSE_CHALLENGES_RESPONSE"),
  ]
}

extension SPClientToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
    2: .same(proto: "expiresInS"),
    3: .same(proto: "refreshAfterS"),
    4: .same(proto: "domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.val) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.refreshAfterS) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.domains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 1)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 2)
    }
    if self.refreshAfterS != 0 {
      try visitor.visitSingularInt32Field(value: self.refreshAfterS, fieldNumber: 3)
    }
    if !self.domains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.domains, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientToken, rhs: SPClientToken) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.refreshAfterS != rhs.refreshAfterS {return false}
    if lhs.domains != rhs.domains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenDomain, rhs: SPClientTokenDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "client"),
    3: .same(proto: "answerData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientInfo?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .client(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .client(v)
        }
      }()
      case 3: try {
        var v: SPClientTokenChallengeAnswerData?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .answerData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .answerData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .requestUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.request {
    case .client?: try {
      guard case .client(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .answerData?: try {
      guard case .answerData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenRequest, rhs: SPClientTokenRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenChallengeAnswerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenChallengeAnswerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenChallengeAnswerData, rhs: SPClientTokenChallengeAnswerData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenChallengeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenChallengeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretAnswer"),
    3: .same(proto: "evaluateJS"),
    4: .same(proto: "hashcash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientSecretHMACAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .clSecretAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .clSecretAnswer(v)
        }
      }()
      case 3: try {
        var v: SPEvaluateJSAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .evaluateJs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .evaluateJs(v)
        }
      }()
      case 4: try {
        var v: SPHashcashChallengeAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .hashcash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.answer {
    case .clSecretAnswer?: try {
      guard case .clSecretAnswer(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .evaluateJs?: try {
      guard case .evaluateJs(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenChallengeAnswer, rhs: SPClientTokenChallengeAnswer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
    3: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientToken?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .token(v)
        }
      }()
      case 3: try {
        var v: SPClientTokenChallengesData?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .challenges(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .challenges(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .responseUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.response {
    case .token?: try {
      guard case .token(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .challenges?: try {
      guard case .challenges(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenResponse, rhs: SPClientTokenResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenChallengesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenChallengesData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.challenges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.challenges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.challenges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenChallengesData, rhs: SPClientTokenChallengesData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.challenges != rhs.challenges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretParameters"),
    3: .same(proto: "jsParameters"),
    4: .same(proto: "hashcashParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientSecretChallenge?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .clSecretParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .clSecretParameters(v)
        }
      }()
      case 3: try {
        var v: SPEvaluateJSChallenge?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .jsParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .jsParameters(v)
        }
      }()
      case 4: try {
        var v: SPHashcashChallenge?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .hashcashParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .hashcashParameters(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.parameters {
    case .clSecretParameters?: try {
      guard case .clSecretParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .jsParameters?: try {
      guard case .jsParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcashParameters?: try {
      guard case .hashcashParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenChallenge, rhs: SPClientTokenChallenge) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenBadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientTokenBadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errMsg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenBadRequest, rhs: SPClientTokenBadRequest) -> Bool {
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
