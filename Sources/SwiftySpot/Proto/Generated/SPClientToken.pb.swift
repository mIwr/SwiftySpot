// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SPClientToken.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum ClientTokenRequestType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case requestUnknown // = 0
  case requestClientDataRequest // = 1
  case requestChallengeAnswersRequest // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .requestUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requestUnknown
    case 1: self = .requestClientDataRequest
    case 2: self = .requestChallengeAnswersRequest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .requestUnknown: return 0
    case .requestClientDataRequest: return 1
    case .requestChallengeAnswersRequest: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ClientTokenRequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClientTokenRequestType] = [
    .requestUnknown,
    .requestClientDataRequest,
    .requestChallengeAnswersRequest,
  ]
}

#endif  // swift(>=4.2)

enum ChallengeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case challengeUnknown // = 0
  case challengeClientSecretHmac // = 1
  case challengeEvaluateJs // = 2
  case challengeHashCash // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .challengeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .challengeUnknown
    case 1: self = .challengeClientSecretHmac
    case 2: self = .challengeEvaluateJs
    case 3: self = .challengeHashCash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .challengeUnknown: return 0
    case .challengeClientSecretHmac: return 1
    case .challengeEvaluateJs: return 2
    case .challengeHashCash: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ChallengeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ChallengeType] = [
    .challengeUnknown,
    .challengeClientSecretHmac,
    .challengeEvaluateJs,
    .challengeHashCash,
  ]
}

#endif  // swift(>=4.2)

enum ClientTokenResponseType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case responseUnknown // = 0
  case responseGrantedTokenResponse // = 1
  case responseChallengesResponse // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .responseUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .responseUnknown
    case 1: self = .responseGrantedTokenResponse
    case 2: self = .responseChallengesResponse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .responseUnknown: return 0
    case .responseGrantedTokenResponse: return 1
    case .responseChallengesResponse: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ClientTokenResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClientTokenResponseType] = [
    .responseUnknown,
    .responseGrantedTokenResponse,
    .responseChallengesResponse,
  ]
}

#endif  // swift(>=4.2)

struct SPClientTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ClientTokenRequestType = .requestUnknown

  var request: SPClientTokenRequest.OneOf_Request? = nil

  var client: SPClientInfo {
    get {
      if case .client(let v)? = request {return v}
      return SPClientInfo()
    }
    set {request = .client(newValue)}
  }

  var answerData: ChallengeAnswerData {
    get {
      if case .answerData(let v)? = request {return v}
      return ChallengeAnswerData()
    }
    set {request = .answerData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case client(SPClientInfo)
    case answerData(ChallengeAnswerData)

  #if !swift(>=4.1)
    static func ==(lhs: SPClientTokenRequest.OneOf_Request, rhs: SPClientTokenRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.client, .client): return {
        guard case .client(let l) = lhs, case .client(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.answerData, .answerData): return {
        guard case .answerData(let l) = lhs, case .answerData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ChallengeAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ChallengeType = .challengeUnknown

  var answer: ChallengeAnswer.OneOf_Answer? = nil

  var clSecretAnswer: ClientSecretHMACAnswer {
    get {
      if case .clSecretAnswer(let v)? = answer {return v}
      return ClientSecretHMACAnswer()
    }
    set {answer = .clSecretAnswer(newValue)}
  }

  var evaluateJs: EvaluateJSAnswer {
    get {
      if case .evaluateJs(let v)? = answer {return v}
      return EvaluateJSAnswer()
    }
    set {answer = .evaluateJs(newValue)}
  }

  var hashcash: HashCashAnswer {
    get {
      if case .hashcash(let v)? = answer {return v}
      return HashCashAnswer()
    }
    set {answer = .hashcash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Answer: Equatable {
    case clSecretAnswer(ClientSecretHMACAnswer)
    case evaluateJs(EvaluateJSAnswer)
    case hashcash(HashCashAnswer)

  #if !swift(>=4.1)
    static func ==(lhs: ChallengeAnswer.OneOf_Answer, rhs: ChallengeAnswer.OneOf_Answer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.clSecretAnswer, .clSecretAnswer): return {
        guard case .clSecretAnswer(let l) = lhs, case .clSecretAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evaluateJs, .evaluateJs): return {
        guard case .evaluateJs(let l) = lhs, case .evaluateJs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcash, .hashcash): return {
        guard case .hashcash(let l) = lhs, case .hashcash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ClientSecretHMACAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hmac: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EvaluateJSAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HashCashAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suffix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChallengeAnswerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///librespot-java: string state = 1;
  var context: String = String()

  var answers: [ChallengeAnswer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ClientTokenResponseType = .responseUnknown

  var response: SPClientTokenResponse.OneOf_Response? = nil

  var token: SPClientToken {
    get {
      if case .token(let v)? = response {return v}
      return SPClientToken()
    }
    set {response = .token(newValue)}
  }

  var challenges: ChallengesData {
    get {
      if case .challenges(let v)? = response {return v}
      return ChallengesData()
    }
    set {response = .challenges(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case token(SPClientToken)
    case challenges(ChallengesData)

  #if !swift(>=4.1)
    static func ==(lhs: SPClientTokenResponse.OneOf_Response, rhs: SPClientTokenResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.token, .token): return {
        guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challenges, .challenges): return {
        guard case .challenges(let l) = lhs, case .challenges(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SPClientToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val: String = String()

  var expiresInS: Int32 = 0

  var refreshAfterS: Int32 = 0

  var domains: [TokenDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TokenDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChallengesData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///librespot-java: string state = 1;
  var context: String = String()

  var challenges: [Challenge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Challenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ChallengeType = .challengeUnknown

  var parameters: Challenge.OneOf_Parameters? = nil

  var clSecretParameters: ClientSecretParameters {
    get {
      if case .clSecretParameters(let v)? = parameters {return v}
      return ClientSecretParameters()
    }
    set {parameters = .clSecretParameters(newValue)}
  }

  var jsParameters: EvaluateJSParameters {
    get {
      if case .jsParameters(let v)? = parameters {return v}
      return EvaluateJSParameters()
    }
    set {parameters = .jsParameters(newValue)}
  }

  var hashcashParameters: HashCashParameters {
    get {
      if case .hashcashParameters(let v)? = parameters {return v}
      return HashCashParameters()
    }
    set {parameters = .hashcashParameters(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Parameters: Equatable {
    case clSecretParameters(ClientSecretParameters)
    case jsParameters(EvaluateJSParameters)
    case hashcashParameters(HashCashParameters)

  #if !swift(>=4.1)
    static func ==(lhs: Challenge.OneOf_Parameters, rhs: Challenge.OneOf_Parameters) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.clSecretParameters, .clSecretParameters): return {
        guard case .clSecretParameters(let l) = lhs, case .clSecretParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jsParameters, .jsParameters): return {
        guard case .jsParameters(let l) = lhs, case .jsParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashParameters, .hashcashParameters): return {
        guard case .hashcashParameters(let l) = lhs, case .hashcashParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ClientSecretParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var salt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EvaluateJSParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var libraries: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HashCashParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var length: Int32 = 0

  var prefix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SPClientTokenBadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ClientTokenRequestType: @unchecked Sendable {}
extension ChallengeType: @unchecked Sendable {}
extension ClientTokenResponseType: @unchecked Sendable {}
extension SPClientTokenRequest: @unchecked Sendable {}
extension SPClientTokenRequest.OneOf_Request: @unchecked Sendable {}
extension ChallengeAnswer: @unchecked Sendable {}
extension ChallengeAnswer.OneOf_Answer: @unchecked Sendable {}
extension ClientSecretHMACAnswer: @unchecked Sendable {}
extension EvaluateJSAnswer: @unchecked Sendable {}
extension HashCashAnswer: @unchecked Sendable {}
extension ChallengeAnswerData: @unchecked Sendable {}
extension SPClientTokenResponse: @unchecked Sendable {}
extension SPClientTokenResponse.OneOf_Response: @unchecked Sendable {}
extension SPClientToken: @unchecked Sendable {}
extension TokenDomain: @unchecked Sendable {}
extension ChallengesData: @unchecked Sendable {}
extension Challenge: @unchecked Sendable {}
extension Challenge.OneOf_Parameters: @unchecked Sendable {}
extension ClientSecretParameters: @unchecked Sendable {}
extension EvaluateJSParameters: @unchecked Sendable {}
extension HashCashParameters: @unchecked Sendable {}
extension SPClientTokenBadRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ClientTokenRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_UNKNOWN"),
    1: .same(proto: "REQUEST_CLIENT_DATA_REQUEST"),
    2: .same(proto: "REQUEST_CHALLENGE_ANSWERS_REQUEST"),
  ]
}

extension ChallengeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHALLENGE_UNKNOWN"),
    1: .same(proto: "CHALLENGE_CLIENT_SECRET_HMAC"),
    2: .same(proto: "CHALLENGE_EVALUATE_JS"),
    3: .same(proto: "CHALLENGE_HASH_CASH"),
  ]
}

extension ClientTokenResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESPONSE_UNKNOWN"),
    1: .same(proto: "RESPONSE_GRANTED_TOKEN_RESPONSE"),
    2: .same(proto: "RESPONSE_CHALLENGES_RESPONSE"),
  ]
}

extension SPClientTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPClientTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "client"),
    3: .same(proto: "answerData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientInfo?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .client(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .client(v)
        }
      }()
      case 3: try {
        var v: ChallengeAnswerData?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .answerData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .answerData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .requestUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.request {
    case .client?: try {
      guard case .client(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .answerData?: try {
      guard case .answerData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenRequest, rhs: SPClientTokenRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChallengeAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretAnswer"),
    3: .same(proto: "evaluateJS"),
    4: .same(proto: "hashcash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: ClientSecretHMACAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .clSecretAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .clSecretAnswer(v)
        }
      }()
      case 3: try {
        var v: EvaluateJSAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .evaluateJs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .evaluateJs(v)
        }
      }()
      case 4: try {
        var v: HashCashAnswer?
        var hadOneofValue = false
        if let current = self.answer {
          hadOneofValue = true
          if case .hashcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.answer = .hashcash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.answer {
    case .clSecretAnswer?: try {
      guard case .clSecretAnswer(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .evaluateJs?: try {
      guard case .evaluateJs(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcash?: try {
      guard case .hashcash(let v)? = self.answer else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChallengeAnswer, rhs: ChallengeAnswer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientSecretHMACAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientSecretHMACAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hmac"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hmac) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hmac.isEmpty {
      try visitor.visitSingularStringField(value: self.hmac, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientSecretHMACAnswer, rhs: ClientSecretHMACAnswer) -> Bool {
    if lhs.hmac != rhs.hmac {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EvaluateJSAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EvaluateJSAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EvaluateJSAnswer, rhs: EvaluateJSAnswer) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HashCashAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashCashAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suffix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HashCashAnswer, rhs: HashCashAnswer) -> Bool {
    if lhs.suffix != rhs.suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChallengeAnswerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeAnswerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "answers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChallengeAnswerData, rhs: ChallengeAnswerData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.answers != rhs.answers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPClientTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
    3: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: SPClientToken?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .token(v)
        }
      }()
      case 3: try {
        var v: ChallengesData?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .challenges(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .challenges(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .responseUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.response {
    case .token?: try {
      guard case .token(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .challenges?: try {
      guard case .challenges(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenResponse, rhs: SPClientTokenResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPClientToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
    2: .same(proto: "expiresInS"),
    3: .same(proto: "refreshAfterS"),
    4: .same(proto: "domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.val) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiresInS) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.refreshAfterS) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.domains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 1)
    }
    if self.expiresInS != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresInS, fieldNumber: 2)
    }
    if self.refreshAfterS != 0 {
      try visitor.visitSingularInt32Field(value: self.refreshAfterS, fieldNumber: 3)
    }
    if !self.domains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.domains, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientToken, rhs: SPClientToken) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.expiresInS != rhs.expiresInS {return false}
    if lhs.refreshAfterS != rhs.refreshAfterS {return false}
    if lhs.domains != rhs.domains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TokenDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TokenDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenDomain, rhs: TokenDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChallengesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengesData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "challenges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.challenges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.challenges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.challenges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChallengesData, rhs: ChallengesData) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.challenges != rhs.challenges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Challenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Challenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "clSecretParameters"),
    3: .same(proto: "jsParameters"),
    4: .same(proto: "hashcashParameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: ClientSecretParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .clSecretParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .clSecretParameters(v)
        }
      }()
      case 3: try {
        var v: EvaluateJSParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .jsParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .jsParameters(v)
        }
      }()
      case 4: try {
        var v: HashCashParameters?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .hashcashParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .hashcashParameters(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .challengeUnknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.parameters {
    case .clSecretParameters?: try {
      guard case .clSecretParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .jsParameters?: try {
      guard case .jsParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hashcashParameters?: try {
      guard case .hashcashParameters(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Challenge, rhs: Challenge) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientSecretParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientSecretParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientSecretParameters, rhs: ClientSecretParameters) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EvaluateJSParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EvaluateJSParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "libraries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.libraries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.libraries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.libraries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EvaluateJSParameters, rhs: EvaluateJSParameters) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.libraries != rhs.libraries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HashCashParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashCashParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
    2: .same(proto: "prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HashCashParameters, rhs: HashCashParameters) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPClientTokenBadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SPClientTokenBadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errMsg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SPClientTokenBadRequest, rhs: SPClientTokenBadRequest) -> Bool {
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
