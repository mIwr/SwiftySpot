// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SPSearch.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Com_Spotify_Searchview_Proto_AutocompleteViewResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hits: [Com_Spotify_Searchview_Proto_Entity] = []

  var autocompleteQueries: [Com_Spotify_Searchview_Proto_AutocompleteQuery] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_MainViewResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hits: [Com_Spotify_Searchview_Proto_Entity] = []

  var recommendations: Com_Spotify_Searchview_Proto_Recommendations {
    get {return _recommendations ?? Com_Spotify_Searchview_Proto_Recommendations()}
    set {_recommendations = newValue}
  }
  /// Returns true if `recommendations` has been explicitly set.
  var hasRecommendations: Bool {return self._recommendations != nil}
  /// Clears the value of `recommendations`. Subsequent reads from it will return its default value.
  mutating func clearRecommendations() {self._recommendations = nil}

  var entityTypes: Data = Data()

  var nextPageToken: String {
    get {return _nextPageToken ?? String()}
    set {_nextPageToken = newValue}
  }
  /// Returns true if `nextPageToken` has been explicitly set.
  var hasNextPageToken: Bool {return self._nextPageToken != nil}
  /// Clears the value of `nextPageToken`. Subsequent reads from it will return its default value.
  mutating func clearNextPageToken() {self._nextPageToken = nil}

  var banner: Com_Spotify_Searchview_Proto_BannerContent {
    get {return _banner ?? Com_Spotify_Searchview_Proto_BannerContent()}
    set {_banner = newValue}
  }
  /// Returns true if `banner` has been explicitly set.
  var hasBanner: Bool {return self._banner != nil}
  /// Clears the value of `banner`. Subsequent reads from it will return its default value.
  mutating func clearBanner() {self._banner = nil}

  var relatedSearches: [Com_Spotify_Searchview_Proto_RelatedSearch] = []

  var autocompleteQueries: [Com_Spotify_Searchview_Proto_AutocompleteQuery] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recommendations: Com_Spotify_Searchview_Proto_Recommendations? = nil
  fileprivate var _nextPageToken: String? = nil
  fileprivate var _banner: Com_Spotify_Searchview_Proto_BannerContent? = nil
}

struct Com_Spotify_Searchview_Proto_Recommendations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Int32 = 0

  var entities: [Com_Spotify_Searchview_Proto_Entity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_BannerContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var title: String = String()

  var desc: String = String()

  var buttonTitle: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_RelatedSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var uri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Entity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var name: String = String()

  var imageUri: String = String()

  var info: Com_Spotify_Searchview_Proto_Entity.OneOf_Info? = nil

  var artist: Com_Spotify_Searchview_Proto_Artist {
    get {
      if case .artist(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Artist()
    }
    set {info = .artist(newValue)}
  }

  var track: Com_Spotify_Searchview_Proto_Track {
    get {
      if case .track(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Track()
    }
    set {info = .track(newValue)}
  }

  var album: Com_Spotify_Searchview_Proto_Album {
    get {
      if case .album(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Album()
    }
    set {info = .album(newValue)}
  }

  var playlist: Com_Spotify_Searchview_Proto_Playlist {
    get {
      if case .playlist(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Playlist()
    }
    set {info = .playlist(newValue)}
  }

  var genre: Com_Spotify_Searchview_Proto_Genre {
    get {
      if case .genre(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Genre()
    }
    set {info = .genre(newValue)}
  }

  var show: Com_Spotify_Searchview_Proto_AudioShow {
    get {
      if case .show(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_AudioShow()
    }
    set {info = .show(newValue)}
  }

  var profile: Com_Spotify_Searchview_Proto_Profile {
    get {
      if case .profile(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Profile()
    }
    set {info = .profile(newValue)}
  }

  var audiobook: Com_Spotify_Searchview_Proto_Audiobook {
    get {
      if case .audiobook(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_Audiobook()
    }
    set {info = .audiobook(newValue)}
  }

  var autocompleteQuery: Com_Spotify_Searchview_Proto_AutocompleteQuery {
    get {
      if case .autocompleteQuery(let v)? = info {return v}
      return Com_Spotify_Searchview_Proto_AutocompleteQuery()
    }
    set {info = .autocompleteQuery(newValue)}
  }

  var serpMetadata: String {
    get {return _serpMetadata ?? String()}
    set {_serpMetadata = newValue}
  }
  /// Returns true if `serpMetadata` has been explicitly set.
  var hasSerpMetadata: Bool {return self._serpMetadata != nil}
  /// Clears the value of `serpMetadata`. Subsequent reads from it will return its default value.
  mutating func clearSerpMetadata() {self._serpMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Info: Equatable {
    case artist(Com_Spotify_Searchview_Proto_Artist)
    case track(Com_Spotify_Searchview_Proto_Track)
    case album(Com_Spotify_Searchview_Proto_Album)
    case playlist(Com_Spotify_Searchview_Proto_Playlist)
    case genre(Com_Spotify_Searchview_Proto_Genre)
    case show(Com_Spotify_Searchview_Proto_AudioShow)
    case profile(Com_Spotify_Searchview_Proto_Profile)
    case audiobook(Com_Spotify_Searchview_Proto_Audiobook)
    case autocompleteQuery(Com_Spotify_Searchview_Proto_AutocompleteQuery)

  #if !swift(>=4.1)
    static func ==(lhs: Com_Spotify_Searchview_Proto_Entity.OneOf_Info, rhs: Com_Spotify_Searchview_Proto_Entity.OneOf_Info) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.artist, .artist): return {
        guard case .artist(let l) = lhs, case .artist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.track, .track): return {
        guard case .track(let l) = lhs, case .track(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.album, .album): return {
        guard case .album(let l) = lhs, case .album(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playlist, .playlist): return {
        guard case .playlist(let l) = lhs, case .playlist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genre, .genre): return {
        guard case .genre(let l) = lhs, case .genre(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.show, .show): return {
        guard case .show(let l) = lhs, case .show(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profile, .profile): return {
        guard case .profile(let l) = lhs, case .profile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audiobook, .audiobook): return {
        guard case .audiobook(let l) = lhs, case .audiobook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autocompleteQuery, .autocompleteQuery): return {
        guard case .autocompleteQuery(let l) = lhs, case .autocompleteQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _serpMetadata: String? = nil
}

struct Com_Spotify_Searchview_Proto_AutocompleteQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var snippet: Com_Spotify_Searchview_Proto_Snippet {
    get {return _snippet ?? Com_Spotify_Searchview_Proto_Snippet()}
    set {_snippet = newValue}
  }
  /// Returns true if `snippet` has been explicitly set.
  var hasSnippet: Bool {return self._snippet != nil}
  /// Clears the value of `snippet`. Subsequent reads from it will return its default value.
  mutating func clearSnippet() {self._snippet = nil}

  var chipText: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snippet: Com_Spotify_Searchview_Proto_Snippet? = nil
}

struct Com_Spotify_Searchview_Proto_Snippet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segments: [Com_Spotify_Searchview_Proto_Segment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Segment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var matched: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Artist {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var verified: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Album {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artistNames: [String] = []

  var type: Int32 = 0

  var releaseYear: Int32 = 0

  var state: Int32 = 0

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var userCountryReleaseIsoTime: String {
    get {return _userCountryReleaseIsoTime ?? String()}
    set {_userCountryReleaseIsoTime = newValue}
  }
  /// Returns true if `userCountryReleaseIsoTime` has been explicitly set.
  var hasUserCountryReleaseIsoTime: Bool {return self._userCountryReleaseIsoTime != nil}
  /// Clears the value of `userCountryReleaseIsoTime`. Subsequent reads from it will return its default value.
  mutating func clearUserCountryReleaseIsoTime() {self._userCountryReleaseIsoTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _userCountryReleaseIsoTime: String? = nil
}

struct Com_Spotify_Searchview_Proto_Playlist {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var personalized: Bool = false

  var ownedBySpotify: Bool = false

  var tracksCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Track {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var explicit: Bool = false

  var windowed: Bool {
    get {return _windowed ?? false}
    set {_windowed = newValue}
  }
  /// Returns true if `windowed` has been explicitly set.
  var hasWindowed: Bool {return self._windowed != nil}
  /// Clears the value of `windowed`. Subsequent reads from it will return its default value.
  mutating func clearWindowed() {self._windowed = nil}

  var album: Com_Spotify_Searchview_Proto_RelatedEntity {
    get {return _album ?? Com_Spotify_Searchview_Proto_RelatedEntity()}
    set {_album = newValue}
  }
  /// Returns true if `album` has been explicitly set.
  var hasAlbum: Bool {return self._album != nil}
  /// Clears the value of `album`. Subsequent reads from it will return its default value.
  mutating func clearAlbum() {self._album = nil}

  var artists: [Com_Spotify_Searchview_Proto_RelatedEntity] = []

  var mogef19: Bool {
    get {return _mogef19 ?? false}
    set {_mogef19 = newValue}
  }
  /// Returns true if `mogef19` has been explicitly set.
  var hasMogef19: Bool {return self._mogef19 != nil}
  /// Clears the value of `mogef19`. Subsequent reads from it will return its default value.
  mutating func clearMogef19() {self._mogef19 = nil}

  var lyricsMatch: Bool {
    get {return _lyricsMatch ?? false}
    set {_lyricsMatch = newValue}
  }
  /// Returns true if `lyricsMatch` has been explicitly set.
  var hasLyricsMatch: Bool {return self._lyricsMatch != nil}
  /// Clears the value of `lyricsMatch`. Subsequent reads from it will return its default value.
  mutating func clearLyricsMatch() {self._lyricsMatch = nil}

  var onDemand: Com_Spotify_Searchview_Proto_OnDemand {
    get {return _onDemand ?? Com_Spotify_Searchview_Proto_OnDemand()}
    set {_onDemand = newValue}
  }
  /// Returns true if `onDemand` has been explicitly set.
  var hasOnDemand: Bool {return self._onDemand != nil}
  /// Clears the value of `onDemand`. Subsequent reads from it will return its default value.
  mutating func clearOnDemand() {self._onDemand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _windowed: Bool? = nil
  fileprivate var _album: Com_Spotify_Searchview_Proto_RelatedEntity? = nil
  fileprivate var _mogef19: Bool? = nil
  fileprivate var _lyricsMatch: Bool? = nil
  fileprivate var _onDemand: Com_Spotify_Searchview_Proto_OnDemand? = nil
}

struct Com_Spotify_Searchview_Proto_AudioShow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherName: String = String()

  var musicAndTalk: Bool = false

  var category: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Genre {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var verified: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_Audiobook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authorNames: [String] = []

  var narratorNames: [String] = []

  var explicit: Bool = false

  var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var desc: String = String()

  var access: Com_Spotify_Searchview_Proto_Access {
    get {return _access ?? Com_Spotify_Searchview_Proto_Access()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  mutating func clearAccess() {self._access = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _access: Com_Spotify_Searchview_Proto_Access? = nil
}

struct Com_Spotify_Searchview_Proto_Access {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signifier: String = String()

  var unlocked: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_RelatedEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Spotify_Searchview_Proto_OnDemand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackUri: String = String()

  var playlistUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Com_Spotify_Searchview_Proto_AutocompleteViewResponse: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_MainViewResponse: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Recommendations: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_BannerContent: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_RelatedSearch: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Entity: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Entity.OneOf_Info: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_AutocompleteQuery: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Snippet: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Segment: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Artist: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Album: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Playlist: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Track: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_AudioShow: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Genre: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Profile: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Audiobook: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_Access: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_RelatedEntity: @unchecked Sendable {}
extension Com_Spotify_Searchview_Proto_OnDemand: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.spotify.searchview.proto"

extension Com_Spotify_Searchview_Proto_AutocompleteViewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutocompleteViewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
    1000: .standard(proto: "autocomplete_queries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 1000: try { try decoder.decodeRepeatedMessageField(value: &self.autocompleteQueries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    if !self.autocompleteQueries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.autocompleteQueries, fieldNumber: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_AutocompleteViewResponse, rhs: Com_Spotify_Searchview_Proto_AutocompleteViewResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs.autocompleteQueries != rhs.autocompleteQueries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_MainViewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MainViewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
    2: .same(proto: "recommendations"),
    3: .standard(proto: "entity_types"),
    4: .standard(proto: "next_page_token"),
    5: .same(proto: "banner"),
    6: .standard(proto: "related_searches"),
    7: .standard(proto: "autocomplete_queries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recommendations) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.entityTypes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._nextPageToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._banner) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.relatedSearches) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.autocompleteQueries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    try { if let v = self._recommendations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.entityTypes.isEmpty {
      try visitor.visitSingularBytesField(value: self.entityTypes, fieldNumber: 3)
    }
    try { if let v = self._nextPageToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._banner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.relatedSearches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relatedSearches, fieldNumber: 6)
    }
    if !self.autocompleteQueries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.autocompleteQueries, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_MainViewResponse, rhs: Com_Spotify_Searchview_Proto_MainViewResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs._recommendations != rhs._recommendations {return false}
    if lhs.entityTypes != rhs.entityTypes {return false}
    if lhs._nextPageToken != rhs._nextPageToken {return false}
    if lhs._banner != rhs._banner {return false}
    if lhs.relatedSearches != rhs.relatedSearches {return false}
    if lhs.autocompleteQueries != rhs.autocompleteQueries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Recommendations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recommendations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "entities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Recommendations, rhs: Com_Spotify_Searchview_Proto_Recommendations) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.entities != rhs.entities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_BannerContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BannerContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "desc"),
    4: .standard(proto: "button_title"),
    5: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.buttonTitle) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 3)
    }
    if !self.buttonTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.buttonTitle, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_BannerContent, rhs: Com_Spotify_Searchview_Proto_BannerContent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.buttonTitle != rhs.buttonTitle {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_RelatedSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RelatedSearch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_RelatedSearch, rhs: Com_Spotify_Searchview_Proto_RelatedSearch) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Entity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
    3: .standard(proto: "image_uri"),
    4: .same(proto: "artist"),
    5: .same(proto: "track"),
    6: .same(proto: "album"),
    7: .same(proto: "playlist"),
    8: .same(proto: "genre"),
    9: .same(proto: "show"),
    11: .same(proto: "profile"),
    13: .same(proto: "audiobook"),
    2046: .standard(proto: "autocomplete_query"),
    2047: .standard(proto: "serp_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageUri) }()
      case 4: try {
        var v: Com_Spotify_Searchview_Proto_Artist?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .artist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .artist(v)
        }
      }()
      case 5: try {
        var v: Com_Spotify_Searchview_Proto_Track?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .track(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .track(v)
        }
      }()
      case 6: try {
        var v: Com_Spotify_Searchview_Proto_Album?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .album(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .album(v)
        }
      }()
      case 7: try {
        var v: Com_Spotify_Searchview_Proto_Playlist?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .playlist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .playlist(v)
        }
      }()
      case 8: try {
        var v: Com_Spotify_Searchview_Proto_Genre?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .genre(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .genre(v)
        }
      }()
      case 9: try {
        var v: Com_Spotify_Searchview_Proto_AudioShow?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .show(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .show(v)
        }
      }()
      case 11: try {
        var v: Com_Spotify_Searchview_Proto_Profile?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .profile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .profile(v)
        }
      }()
      case 13: try {
        var v: Com_Spotify_Searchview_Proto_Audiobook?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .audiobook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .audiobook(v)
        }
      }()
      case 2046: try {
        var v: Com_Spotify_Searchview_Proto_AutocompleteQuery?
        var hadOneofValue = false
        if let current = self.info {
          hadOneofValue = true
          if case .autocompleteQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.info = .autocompleteQuery(v)
        }
      }()
      case 2047: try { try decoder.decodeSingularStringField(value: &self._serpMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.imageUri.isEmpty {
      try visitor.visitSingularStringField(value: self.imageUri, fieldNumber: 3)
    }
    switch self.info {
    case .artist?: try {
      guard case .artist(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .track?: try {
      guard case .track(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .album?: try {
      guard case .album(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .playlist?: try {
      guard case .playlist(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .genre?: try {
      guard case .genre(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .show?: try {
      guard case .show(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .profile?: try {
      guard case .profile(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .audiobook?: try {
      guard case .audiobook(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .autocompleteQuery?: try {
      guard case .autocompleteQuery(let v)? = self.info else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2046)
    }()
    case nil: break
    }
    try { if let v = self._serpMetadata {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2047)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Entity, rhs: Com_Spotify_Searchview_Proto_Entity) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.imageUri != rhs.imageUri {return false}
    if lhs.info != rhs.info {return false}
    if lhs._serpMetadata != rhs._serpMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_AutocompleteQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutocompleteQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "snippet"),
    100: .standard(proto: "chip_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._snippet) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self.chipText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try { if let v = self._snippet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.chipText.isEmpty {
      try visitor.visitSingularStringField(value: self.chipText, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_AutocompleteQuery, rhs: Com_Spotify_Searchview_Proto_AutocompleteQuery) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs._snippet != rhs._snippet {return false}
    if lhs.chipText != rhs.chipText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Snippet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snippet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Snippet, rhs: Com_Spotify_Searchview_Proto_Snippet) -> Bool {
    if lhs.segments != rhs.segments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Segment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "matched"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.matched) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.matched != false {
      try visitor.visitSingularBoolField(value: self.matched, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Segment, rhs: Com_Spotify_Searchview_Proto_Segment) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.matched != rhs.matched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Artist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Artist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Artist, rhs: Com_Spotify_Searchview_Proto_Artist) -> Bool {
    if lhs.verified != rhs.verified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Album: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Album"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artist_names"),
    2: .same(proto: "type"),
    3: .standard(proto: "release_year"),
    4: .same(proto: "state"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "user_country_release_iso_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.artistNames) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.releaseYear) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.state) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._userCountryReleaseIsoTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.artistNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.artistNames, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if self.releaseYear != 0 {
      try visitor.visitSingularInt32Field(value: self.releaseYear, fieldNumber: 3)
    }
    if self.state != 0 {
      try visitor.visitSingularInt32Field(value: self.state, fieldNumber: 4)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._userCountryReleaseIsoTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Album, rhs: Com_Spotify_Searchview_Proto_Album) -> Bool {
    if lhs.artistNames != rhs.artistNames {return false}
    if lhs.type != rhs.type {return false}
    if lhs.releaseYear != rhs.releaseYear {return false}
    if lhs.state != rhs.state {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._userCountryReleaseIsoTime != rhs._userCountryReleaseIsoTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Playlist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Playlist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "personalized"),
    2: .standard(proto: "owned_by_spotify"),
    3: .standard(proto: "tracks_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.personalized) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ownedBySpotify) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.tracksCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.personalized != false {
      try visitor.visitSingularBoolField(value: self.personalized, fieldNumber: 1)
    }
    if self.ownedBySpotify != false {
      try visitor.visitSingularBoolField(value: self.ownedBySpotify, fieldNumber: 2)
    }
    if self.tracksCount != 0 {
      try visitor.visitSingularInt32Field(value: self.tracksCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Playlist, rhs: Com_Spotify_Searchview_Proto_Playlist) -> Bool {
    if lhs.personalized != rhs.personalized {return false}
    if lhs.ownedBySpotify != rhs.ownedBySpotify {return false}
    if lhs.tracksCount != rhs.tracksCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Track"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "explicit"),
    2: .same(proto: "windowed"),
    3: .same(proto: "album"),
    4: .same(proto: "artists"),
    6: .same(proto: "mogef19"),
    7: .standard(proto: "lyrics_match"),
    8: .standard(proto: "on_demand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.explicit) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._windowed) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._album) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.artists) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._mogef19) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._lyricsMatch) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._onDemand) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.explicit != false {
      try visitor.visitSingularBoolField(value: self.explicit, fieldNumber: 1)
    }
    try { if let v = self._windowed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._album {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.artists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artists, fieldNumber: 4)
    }
    try { if let v = self._mogef19 {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lyricsMatch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._onDemand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Track, rhs: Com_Spotify_Searchview_Proto_Track) -> Bool {
    if lhs.explicit != rhs.explicit {return false}
    if lhs._windowed != rhs._windowed {return false}
    if lhs._album != rhs._album {return false}
    if lhs.artists != rhs.artists {return false}
    if lhs._mogef19 != rhs._mogef19 {return false}
    if lhs._lyricsMatch != rhs._lyricsMatch {return false}
    if lhs._onDemand != rhs._onDemand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_AudioShow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioShow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_name"),
    3: .standard(proto: "music_and_talk"),
    4: .same(proto: "category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publisherName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.musicAndTalk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.category) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 1)
    }
    if self.musicAndTalk != false {
      try visitor.visitSingularBoolField(value: self.musicAndTalk, fieldNumber: 3)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_AudioShow, rhs: Com_Spotify_Searchview_Proto_AudioShow) -> Bool {
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.musicAndTalk != rhs.musicAndTalk {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Genre: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Genre"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Genre, rhs: Com_Spotify_Searchview_Proto_Genre) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Profile, rhs: Com_Spotify_Searchview_Proto_Profile) -> Bool {
    if lhs.verified != rhs.verified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Audiobook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Audiobook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "author_names"),
    2: .standard(proto: "narrator_names"),
    3: .same(proto: "explicit"),
    4: .same(proto: "duration"),
    5: .same(proto: "desc"),
    6: .same(proto: "access"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.authorNames) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.narratorNames) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.explicit) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authorNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.authorNames, fieldNumber: 1)
    }
    if !self.narratorNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.narratorNames, fieldNumber: 2)
    }
    if self.explicit != false {
      try visitor.visitSingularBoolField(value: self.explicit, fieldNumber: 3)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 5)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Audiobook, rhs: Com_Spotify_Searchview_Proto_Audiobook) -> Bool {
    if lhs.authorNames != rhs.authorNames {return false}
    if lhs.narratorNames != rhs.narratorNames {return false}
    if lhs.explicit != rhs.explicit {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs._access != rhs._access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Access"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signifier"),
    2: .same(proto: "unlocked"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signifier) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.unlocked) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signifier.isEmpty {
      try visitor.visitSingularStringField(value: self.signifier, fieldNumber: 1)
    }
    if self.unlocked != false {
      try visitor.visitSingularBoolField(value: self.unlocked, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_Access, rhs: Com_Spotify_Searchview_Proto_Access) -> Bool {
    if lhs.signifier != rhs.signifier {return false}
    if lhs.unlocked != rhs.unlocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_RelatedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RelatedEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_RelatedEntity, rhs: Com_Spotify_Searchview_Proto_RelatedEntity) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Spotify_Searchview_Proto_OnDemand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OnDemand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_uri"),
    2: .standard(proto: "playlist_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.playlistUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackUri.isEmpty {
      try visitor.visitSingularStringField(value: self.trackUri, fieldNumber: 1)
    }
    if !self.playlistUri.isEmpty {
      try visitor.visitSingularStringField(value: self.playlistUri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Spotify_Searchview_Proto_OnDemand, rhs: Com_Spotify_Searchview_Proto_OnDemand) -> Bool {
    if lhs.trackUri != rhs.trackUri {return false}
    if lhs.playlistUri != rhs.playlistUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
