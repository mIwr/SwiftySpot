// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: MetadataModel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Meta copyright type
public enum SPMetadataCopyrightType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case p // = 0
  case c // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .p
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .p
    case 1: self = .c
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .p: return 0
    case .c: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SPMetadataCopyrightType] = [
    .p,
    .c,
  ]

}

public enum SPMetadataAlbumType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case album // = 1
  case single // = 2
  case compilation // = 3
  case ep // = 4
  case audiobook // = 5
  case podcast // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .album
    case 2: self = .single
    case 3: self = .compilation
    case 4: self = .ep
    case 5: self = .audiobook
    case 6: self = .podcast
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .album: return 1
    case .single: return 2
    case .compilation: return 3
    case .ep: return 4
    case .audiobook: return 5
    case .podcast: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SPMetadataAlbumType] = [
    .unknown,
    .album,
    .single,
    .compilation,
    .ep,
    .audiobook,
    .podcast,
  ]

}

///Artist role type
public enum SPMetadataArtistRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case mainArtist // = 1
  case featuredArtist // = 2
  case remixer // = 3
  case actor // = 4
  case composer // = 5
  case conductor // = 6
  case orchestra // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .mainArtist
    case 2: self = .featuredArtist
    case 3: self = .remixer
    case 4: self = .actor
    case 5: self = .composer
    case 6: self = .conductor
    case 7: self = .orchestra
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .mainArtist: return 1
    case .featuredArtist: return 2
    case .remixer: return 3
    case .actor: return 4
    case .composer: return 5
    case .conductor: return 6
    case .orchestra: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SPMetadataArtistRole] = [
    .unknown,
    .mainArtist,
    .featuredArtist,
    .remixer,
    .actor,
    .composer,
    .conductor,
    .orchestra,
  ]

}

///Audio file format (codec)
public enum SPMetadataAudioFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case oggVorbis96 // = 0
  case oggVorbis160 // = 1
  case oggVorbis320 // = 2
  case mp3256 // = 3
  case mp3320 // = 4
  case mp3160 // = 5
  case mp396 // = 6
  case mp3160Enc // = 7
  case aac24 // = 8
  case aac48 // = 9
  case mp4128 // = 10
  case mp4128Dual // = 11
  case mp4128Cbcs // = 12
  case mp4256 // = 13
  case mp4256Dual // = 14
  case mp4256Cbcs // = 15
  case flacFlac // = 16
  case mp4Flac // = 17
  case xheAac24 // = 18
  case xheAac16 // = 19
  case xheAac12 // = 20
  case flacFlac24Bit // = 22
  case UNRECOGNIZED(Int)

  public init() {
    self = .oggVorbis96
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .oggVorbis96
    case 1: self = .oggVorbis160
    case 2: self = .oggVorbis320
    case 3: self = .mp3256
    case 4: self = .mp3320
    case 5: self = .mp3160
    case 6: self = .mp396
    case 7: self = .mp3160Enc
    case 8: self = .aac24
    case 9: self = .aac48
    case 10: self = .mp4128
    case 11: self = .mp4128Dual
    case 12: self = .mp4128Cbcs
    case 13: self = .mp4256
    case 14: self = .mp4256Dual
    case 15: self = .mp4256Cbcs
    case 16: self = .flacFlac
    case 17: self = .mp4Flac
    case 18: self = .xheAac24
    case 19: self = .xheAac16
    case 20: self = .xheAac12
    case 22: self = .flacFlac24Bit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .oggVorbis96: return 0
    case .oggVorbis160: return 1
    case .oggVorbis320: return 2
    case .mp3256: return 3
    case .mp3320: return 4
    case .mp3160: return 5
    case .mp396: return 6
    case .mp3160Enc: return 7
    case .aac24: return 8
    case .aac48: return 9
    case .mp4128: return 10
    case .mp4128Dual: return 11
    case .mp4128Cbcs: return 12
    case .mp4256: return 13
    case .mp4256Dual: return 14
    case .mp4256Cbcs: return 15
    case .flacFlac: return 16
    case .mp4Flac: return 17
    case .xheAac24: return 18
    case .xheAac16: return 19
    case .xheAac12: return 20
    case .flacFlac24Bit: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SPMetadataAudioFormat] = [
    .oggVorbis96,
    .oggVorbis160,
    .oggVorbis320,
    .mp3256,
    .mp3320,
    .mp3160,
    .mp396,
    .mp3160Enc,
    .aac24,
    .aac48,
    .mp4128,
    .mp4128Dual,
    .mp4128Cbcs,
    .mp4256,
    .mp4256Dual,
    .mp4256Cbcs,
    .flacFlac,
    .mp4Flac,
    .xheAac24,
    .xheAac16,
    .xheAac12,
    .flacFlac24Bit,
  ]

}

///Bio meta data
public struct SPMetadataBiography: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Bio text
  public var text: String = String()

  ///Biography portraits
  public var portraitVariants: [SPMetadataImage] = []

  ///Biography portraits by sizes group
  public var portraitGroups: [SPMetadataImageGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///External ID meta info
public struct SPMetadataExternalId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Image meta info
public struct SPMetadataImage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Image ID
  public var fileID: Data = Data()

  ///Image size in bytes
  public var size: Int32 = 0

  ///Image width in pixels
  public var width: Int32 = 0

  ///Image height in pixels
  public var height: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Images array
public struct SPMetadataImageGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Images
  public var images: [SPMetadataImage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Sale period meta info
public struct SPMetadataSalePeriod: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Restrictions info
  public var restrictions: [SPMetadataRestriction] = []

  ///Sale period start timestamp
  public var start: SPMetadataDate {
    get {return _start ?? SPMetadataDate()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  ///Sale period end timestamp
  public var end: SPMetadataDate {
    get {return _end ?? SPMetadataDate()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SPMetadataDate? = nil
  fileprivate var _end: SPMetadataDate? = nil
}

///Restriction meta info
public struct SPMetadataRestriction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Profile product types requirements
  public var catalogue: [Int32] = []

  ///repeated string countries_allowed = 2;
  ///repeated string countries_forbidden = 3;
  ///Restriction type
  public var type: Int32 = 0

  ///Profile product requirements
  public var catalogueStr: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Date metadata info. Values from API is x2 of real. Can trigger it by year (4046 = 2023 * 2) or month (16 = 8 * 2)
public struct SPMetadataDate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Date year. X2 from real value
  public var stockYear: Int32 = 0

  ///Date month. X2 from real value
  public var stockMonth: Int32 = 0

  ///Date day. X2 from real value
  public var stockDay: Int32 = 0

  ///Date hour. X2 from real value
  public var stockHour: Int32 = 0

  ///Date minute. X2 from real value
  public var stockMinute: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Availability meta info
public struct SPMetadataAvailability: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ////Profile product types requirements
  public var catalogueStr: [String] = []

  ///Availability start timestamp
  public var start: SPMetadataDate {
    get {return _start ?? SPMetadataDate()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SPMetadataDate? = nil
}

///Copyright meta info
public struct SPMetadataCopyright: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Copyright type
  public var type: SPMetadataCopyrightType = .p

  ///Copiryght text
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Content rating meta info
public struct SPMetadataContentRating: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Country code
  public var country: String = String()

  ///Rating rags
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Licensor meta info
public struct SPMetadataLicensor: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Licensor UUID
  public var uuid: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SPMetadataBlock: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var countries: String = String()

  public var type: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Localized string meta info
public struct SPMetadataLocalizedString: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Language code
  public var language: String = String()

  ///Localized string value
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Artist activity period meta info
public struct SPMetadataActivityPeriod: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Period start year
  public var startYear: Int32 = 0

  ///Period end year
  public var endYear: Int32 {
    get {return _endYear ?? 0}
    set {_endYear = newValue}
  }
  /// Returns true if `endYear` has been explicitly set.
  public var hasEndYear: Bool {return self._endYear != nil}
  /// Clears the value of `endYear`. Subsequent reads from it will return its default value.
  public mutating func clearEndYear() {self._endYear = nil}

  ///Period decade
  public var decade: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endYear: Int32? = nil
}

///Artist and role meta info
public struct SPMetadataArtistWithRole: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Artist GID
  public var gid: Data = Data()

  ///Artist name
  public var name: String = String()

  ///Artist role
  public var role: SPMetadataArtistRole = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Audio file meta info
public struct SPMetadataAudioFile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///File ID
  public var fileID: Data = Data()

  ///Audio file format (codec)
  public var format: SPMetadataAudioFormat = .oggVorbis96

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "spotify.metadata"

extension SPMetadataCopyrightType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "P"),
    1: .same(proto: "C"),
  ]
}

extension SPMetadataAlbumType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ALBUM"),
    2: .same(proto: "SINGLE"),
    3: .same(proto: "COMPILATION"),
    4: .same(proto: "EP"),
    5: .same(proto: "AUDIOBOOK"),
    6: .same(proto: "PODCAST"),
  ]
}

extension SPMetadataArtistRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARTIST_ROLE_UNKNOWN"),
    1: .same(proto: "ARTIST_ROLE_MAIN_ARTIST"),
    2: .same(proto: "ARTIST_ROLE_FEATURED_ARTIST"),
    3: .same(proto: "ARTIST_ROLE_REMIXER"),
    4: .same(proto: "ARTIST_ROLE_ACTOR"),
    5: .same(proto: "ARTIST_ROLE_COMPOSER"),
    6: .same(proto: "ARTIST_ROLE_CONDUCTOR"),
    7: .same(proto: "ARTIST_ROLE_ORCHESTRA"),
  ]
}

extension SPMetadataAudioFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OGG_VORBIS_96"),
    1: .same(proto: "OGG_VORBIS_160"),
    2: .same(proto: "OGG_VORBIS_320"),
    3: .same(proto: "MP3_256"),
    4: .same(proto: "MP3_320"),
    5: .same(proto: "MP3_160"),
    6: .same(proto: "MP3_96"),
    7: .same(proto: "MP3_160_ENC"),
    8: .same(proto: "AAC_24"),
    9: .same(proto: "AAC_48"),
    10: .same(proto: "MP4_128"),
    11: .same(proto: "MP4_128_DUAL"),
    12: .same(proto: "MP4_128_CBCS"),
    13: .same(proto: "MP4_256"),
    14: .same(proto: "MP4_256_DUAL"),
    15: .same(proto: "MP4_256_CBCS"),
    16: .same(proto: "FLAC_FLAC"),
    17: .same(proto: "MP4_FLAC"),
    18: .same(proto: "XHE_AAC_24"),
    19: .same(proto: "XHE_AAC_16"),
    20: .same(proto: "XHE_AAC_12"),
    22: .same(proto: "FLAC_FLAC_24BIT"),
  ]
}

extension SPMetadataBiography: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Biography"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "portrait_variants"),
    3: .standard(proto: "portrait_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.portraitVariants) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.portraitGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.portraitVariants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.portraitVariants, fieldNumber: 2)
    }
    if !self.portraitGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.portraitGroups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataBiography, rhs: SPMetadataBiography) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.portraitVariants != rhs.portraitVariants {return false}
    if lhs.portraitGroups != rhs.portraitGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataExternalId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataExternalId, rhs: SPMetadataExternalId) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "size"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularBytesField(value: self.fileID, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataImage, rhs: SPMetadataImage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.size != rhs.size {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataImageGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "images"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataImageGroup, rhs: SPMetadataImageGroup) -> Bool {
    if lhs.images != rhs.images {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataSalePeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SalePeriod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "restrictions"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.restrictions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.restrictions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.restrictions, fieldNumber: 1)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataSalePeriod, rhs: SPMetadataSalePeriod) -> Bool {
    if lhs.restrictions != rhs.restrictions {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Restriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "catalogue"),
    4: .same(proto: "type"),
    5: .standard(proto: "catalogue_str"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.catalogue) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.catalogueStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.catalogue.isEmpty {
      try visitor.visitPackedInt32Field(value: self.catalogue, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 4)
    }
    if !self.catalogueStr.isEmpty {
      try visitor.visitRepeatedStringField(value: self.catalogueStr, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataRestriction, rhs: SPMetadataRestriction) -> Bool {
    if lhs.catalogue != rhs.catalogue {return false}
    if lhs.type != rhs.type {return false}
    if lhs.catalogueStr != rhs.catalogueStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Date"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stockYear"),
    2: .same(proto: "stockMonth"),
    3: .same(proto: "stockDay"),
    4: .same(proto: "stockHour"),
    5: .same(proto: "stockMinute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stockYear) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stockMonth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stockDay) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.stockHour) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.stockMinute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stockYear != 0 {
      try visitor.visitSingularInt32Field(value: self.stockYear, fieldNumber: 1)
    }
    if self.stockMonth != 0 {
      try visitor.visitSingularInt32Field(value: self.stockMonth, fieldNumber: 2)
    }
    if self.stockDay != 0 {
      try visitor.visitSingularInt32Field(value: self.stockDay, fieldNumber: 3)
    }
    if self.stockHour != 0 {
      try visitor.visitSingularInt32Field(value: self.stockHour, fieldNumber: 4)
    }
    if self.stockMinute != 0 {
      try visitor.visitSingularInt32Field(value: self.stockMinute, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataDate, rhs: SPMetadataDate) -> Bool {
    if lhs.stockYear != rhs.stockYear {return false}
    if lhs.stockMonth != rhs.stockMonth {return false}
    if lhs.stockDay != rhs.stockDay {return false}
    if lhs.stockHour != rhs.stockHour {return false}
    if lhs.stockMinute != rhs.stockMinute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataAvailability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Availability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "catalogue_str"),
    2: .same(proto: "start"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.catalogueStr) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.catalogueStr.isEmpty {
      try visitor.visitRepeatedStringField(value: self.catalogueStr, fieldNumber: 1)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataAvailability, rhs: SPMetadataAvailability) -> Bool {
    if lhs.catalogueStr != rhs.catalogueStr {return false}
    if lhs._start != rhs._start {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataCopyright: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Copyright"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .p {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataCopyright, rhs: SPMetadataCopyright) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataContentRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentRating"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "country"),
    2: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 1)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataContentRating, rhs: SPMetadataContentRating) -> Bool {
    if lhs.country != rhs.country {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataLicensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Licensor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularBytesField(value: self.uuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataLicensor, rhs: SPMetadataLicensor) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitSingularStringField(value: self.countries, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataBlock, rhs: SPMetadataBlock) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataLocalizedString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataLocalizedString, rhs: SPMetadataLocalizedString) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataActivityPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityPeriod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_year"),
    2: .standard(proto: "end_year"),
    3: .same(proto: "decade"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startYear) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._endYear) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.decade) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.startYear != 0 {
      try visitor.visitSingularInt32Field(value: self.startYear, fieldNumber: 1)
    }
    try { if let v = self._endYear {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if self.decade != 0 {
      try visitor.visitSingularInt32Field(value: self.decade, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataActivityPeriod, rhs: SPMetadataActivityPeriod) -> Bool {
    if lhs.startYear != rhs.startYear {return false}
    if lhs._endYear != rhs._endYear {return false}
    if lhs.decade != rhs.decade {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataArtistWithRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArtistWithRole"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularBytesField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.role != .unknown {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataArtistWithRole, rhs: SPMetadataArtistWithRole) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SPMetadataAudioFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularBytesField(value: self.fileID, fieldNumber: 1)
    }
    if self.format != .oggVorbis96 {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SPMetadataAudioFile, rhs: SPMetadataAudioFile) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
